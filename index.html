<!-- START Part 1 of 6 -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>UFL WORLD & CAF RANKINGS - FINAL V4</title>

<!-- Firebase (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>

<!-- Tailwind (for utility) and FontAwesome -->
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&family=Oxanium:wght@300;400;600;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>

<style>
:root{ --gold:#FFD700; --muted:#9ca3af; --card-bg: rgba(8,8,10,0.56); }
html,body{height:100%;margin:0;padding:0}
body{
  font-family:'Oxanium',sans-serif;
  background:
    radial-gradient(ellipse at center, rgba(255,215,140,0.03) 0%, rgba(0,0,0,0.5) 60%, rgba(0,0,0,0.75) 100%),
    linear-gradient(120deg,#070707 0%, #0f0f0f 40%, #070707 100%),
    linear-gradient(45deg, rgba(255,255,255,0.015) 0%, rgba(0,0,0,0.05) 50%, rgba(255,255,255,0.01) 100%);
  color:#fff; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  min-height:100vh; padding-bottom:48px;
}

.container {
  max-width: 1100px;
  margin: 18px auto;
  padding: 0 16px;
  box-sizing: border-box; /* ‚úÖ prevents overflow ‚Äúwobble‚Äù */
}

.frosted{ background:var(--card-bg); border:1px solid rgba(255,215,0,0.06); backdrop-filter: blur(7px); padding:14px; border-radius:12px; }
.header{ font-family:'Orbitron',sans-serif; font-size:28px; color:var(--gold); text-align:center; margin-bottom:6px; }
.submuted{ color:var(--muted); font-size:13px; text-align:center; margin-bottom:8px; }

.tabs {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
  padding: 6px 8px;
  justify-content: flex-start;
  flex-wrap: nowrap;             /* ‚ùå disable wrapping */
  overflow-x: auto;              /* ‚úÖ enable horizontal scroll */
  overflow-y: hidden;
  scrollbar-width: thin;         /* firefox thin scrollbar */
  scroll-behavior: smooth;       /* smooth drag/scroll */
  -webkit-overflow-scrolling: touch; /* mobile momentum scroll */
}
.tabs::-webkit-scrollbar {
  height: 6px;
}
.tabs::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.2);
  border-radius: 4px;
}

.tab-btn{ background:transparent; border:0; padding:8px 12px; cursor:pointer; color:#ddd; border-bottom:2px solid transparent; font-family:'Orbitron'; font-size:13px; text-transform:uppercase; letter-spacing:1px; }
.tab-active{ color:var(--gold); border-bottom-color:var(--gold); }

.grid-main{ display:grid; grid-template-columns:320px 1fr; gap:18px; align-items:start; }
.champion-card{ border-radius:14px; padding:18px; border:1px solid rgba(255,215,0,0.16); background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12)); animation: floaty 6s ease-in-out infinite; position:relative; }
@keyframes floaty{0%{transform:translateY(0)}50%{transform:translateY(-6px)}100%{transform:translateY(0)}}
.champ-crown{ font-size:28px; color:var(--gold); display:block; text-align:center; margin-top:-6px; }
.champ-title{ font-size:12px; color:#e9d9a0; letter-spacing:1px; text-transform:uppercase; text-align:center; }
.champ-name{ font-family:'Orbitron'; font-size:22px; text-align:center; margin-top:6px; color:var(--gold); cursor:pointer; }
.champ-meta{ font-size:13px; text-align:center; color:#ddd; margin-top:6px; }

.rank-list{ display:flex; flex-direction:column; gap:8px; max-height:540px; overflow:auto; padding-right:6px; }
.rank-row{ display:flex; justify-content:space-between; align-items:center; padding:12px; border-radius:10px; background:rgba(0,0,0,0.18); }
.fighter-link{ color:inherit; text-decoration:none; cursor:pointer; font-weight:600; font-family:Orbitron; }
.small-muted{ color:var(--muted); font-size:12px; }
.icon-champ{ color:var(--gold); margin-left:6px; }

table{ width:100%; border-collapse:collapse; }
th,td{ padding:8px 6px; text-align:left; border-bottom:1px solid rgba(255,255,255,0.03); font-size:13px; }
.btn{ padding:8px 10px; border-radius:8px; cursor:pointer; border:0; }
.btn-primary{ background:#2563eb; color:#fff; }
.btn-danger{ background:#c0392b; color:#fff; }
.btn-yellow{ background:var(--gold); color:#000; }

.hidden{ display:none !important; }
.muted{ color:var(--muted); font-size:13px; }

.modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:60; }
.modal{ background:rgba(6,6,6,0.94); padding:16px; border-radius:10px; max-width:900px; width:100%; color:#fff; }

input,select{ padding:8px; border-radius:6px; background:rgba(0,0,0,0.36); color:#fff; border:1px solid rgba(255,255,255,0.04); }

.players-header,.fights-header{ display:flex; justify-content:space-between; align-items:center; padding:8px 12px; border-radius:8px; background:rgba(255,255,255,0.02); margin-bottom:6px; font-weight:700; font-family:Orbitron; }
.players-columns{ display:flex; justify-content:space-between; gap:6px; width:100%; }
.players-column-left{ width:70%; display:flex; align-items:center; gap:8px; }
.players-column-right{ width:30%; text-align:right; }

.fights-row {
  display: grid;
  grid-template-columns: 120px 1fr 140px 160px; /* DATE | FIGHT | METHOD | WINNER */
  gap: 16px; /* ‚úÖ extra space for readability */
  align-items: center;
  width: 100%;
  padding: 10px 6px;
  border-bottom: 1px solid rgba(255,255,255,0.06);
}

.streak{ font-size:14px; margin-right:6px; }
.streak.hot{ color:#ffb86b; }
.streak.cold{ color:#7ad3ff; }
.streak.neutral{ color:#d1d5db; }

.breakdown{ border-top:1px solid rgba(255,215,0,0.08); margin-top:12px; padding-top:10px; color:var(--muted); font-size:13px; }
.breakdown strong{ color:var(--gold); }

.badge{ margin-right:8px; padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,215,0,0.15); font-size:14px; cursor:help; transition:all 0.15s ease; display:inline-block; }
.badge:hover{ background:rgba(255,215,0,0.08); transform:translateY(-2px); }

.rank-num{width:40px;text-align:center;color:#9ca3af;font-weight:700;margin-right:8px;}
.fighter-row {
  display: grid;
  grid-template-columns: 40px 1fr 100px 80px; /* Rank | Name | Record | Points */
  align-items: center;
  gap: 12px;
  padding: 10px;
  border-radius: 8px;
  background: rgba(0,0,0,0.14);
}

.fighter-name {
  text-align: left;
}

.fighter-record {
  text-align: center;
  width: 100%;
}

.fighter-points {
  text-align: right;
  width: 80px;
}

/* ---------- RESPONSIVE RULES (CONSOLIDATED) ---------- */

/* Small screen adjustments (generic) */
@media (max-width:900px){
  .grid-main{ grid-template-columns:1fr !important; }
  .champ-card{ margin:0 auto; max-width:420px; }
  .tabs{ justify-content:flex-start; overflow:auto; padding-left:8px; }
  .fights-columns,.fights-row{ grid-template-columns:1fr 120px 100px 100px; }
}

/* ---------- ADMIN GRID ‚Äî single authoritative block ---------- */

/* Desktop: admin grid two columns */
#admin-grid {
  display: grid;                    /* ensure grid layout is explicitly set */
  grid-template-columns: 1fr 1fr;   /* two columns on desktop */
  grid-auto-rows: auto;
  gap: 16px;
  align-items: start;
  width: 100%;
  box-sizing: border-box;
}

/* Child boxes are allowed to shrink (prevents narrow collapsed columns) */
#admin-grid > .frosted {
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  min-width: 0; /* CRITICAL: allow shrinking in grid items */
}

/* If some children use inline spanning (grid-column:span 2) let desktop keep that */
#admin-grid > .frosted[style*="grid-column"] {
  /* no change on desktop; preserves visual spanning */
}

/* ---------- Mobile: force one-column stack and neutralize inline spans ---------- */
@media (max-width:900px) {

  /* Force single-column grid on mobile (keeps source order) */
  #admin-grid {
    display: grid !important;
    grid-template-columns: 1fr !important;
    gap: 12px !important;
    align-items: stretch !important;
  }

  /* Neutralize any inline grid-column spans that may exist on children */
  #admin-grid > .frosted[style*="grid-column"] {
    grid-column: auto !important;
  }

  /* Make sure each child fills width and can shrink properly */
  #admin-grid > .frosted {
    width: 100% !important;
    max-width: 100% !important;
    min-width: 0 !important;
    box-sizing: border-box !important;
    overflow-x: hidden !important;
    margin-bottom: 8px !important;
  }

  /* Ensure controls inside admin do not force overflow */
  #admin-grid input,
  #admin-grid select,
  #admin-grid button,
  #admin-grid table {
    max-width: 100% !important;
    box-sizing: border-box !important;
    min-width: 0 !important;
  }
}

/* ---------- keep other global rules intact ---------- */
html, body {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow-x: hidden; /* prevents horizontal scroll wobble */
  background-color: #000;
}

@media (min-width:900px) {
  .tabs { justify-content: center; }
}

</style>
</head>
<body>
  <div class="container">
    <div class="frosted" style="margin-bottom:12px;">
      <div class="header">UFL WORLD RANKINGS</div>
      <div class="submuted">HOME OF THE BEST</div>
    </div>
<!-- END Part 1 of 6 -->
<!-- START Part 2 of 6 -->
<div class="tabs" role="tablist" aria-label="Main tabs">
  <button id="btn-world" class="tab-btn tab-active" onclick="switchTab('world')"><i class="fas fa-globe-americas"></i>&nbsp;UFL WORLD</button>
<button id="btn-rbc" class="tab-btn" onclick="switchTab('rbc')"><i class="fas fa-crown"></i>&nbsp;RBC</button>
<button id="btn-abc" class="tab-btn" onclick="switchTab('abc')"><i class="fas fa-flag-usa"></i>&nbsp;ABC</button>
<button id="btn-caf" class="tab-btn" onclick="switchTab('caf')"><i class="fas fa-user-pen"></i>&nbsp;UFC CAF</button>
<button id="btn-players" class="tab-btn" onclick="switchTab('players')"><i class="fas fa-user-friends"></i>&nbsp;PLAYERS</button>
<button id="btn-fights" class="tab-btn" onclick="switchTab('fights')"><i class="fas fa-list"></i>&nbsp;FIGHTS</button>
<button id="btn-admin" class="tab-btn" onclick="switchTab('admin')"><i class="fas fa-lock"></i>&nbsp;ADMIN</button>

</div>

<div class="frosted">
  <!-- WORLD TAB -->
  <div id="world-tab" class="tab-panel">
    <div class="grid-main">
      <div>
        <div id="world-champion-card" class="champion-card"></div>
      </div>
      <div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <h2 style="margin:0;font-family:Orbitron;">UFL WORLD TOP 30</h2>
        </div>
        <div id="world-rankings" class="rank-list"></div>
      </div>
    </div>
  </div>

<!-- üèÜ RBC TAB -->
<div id="rbc-tab" class="tab-panel hidden" style="margin-top:14px;">
  <div class="grid-main">
    <div>
      <div id="rbc-champion-card" class="champion-card"></div>
    </div>
    <div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h2 style="margin:0;font-family:Orbitron;">ROYAL BOXING COMMISSION</h2>
      </div>
      <div id="rbc-rankings" class="rank-list"></div>
    </div>
  </div>
</div>

<!-- üèÜ ABC TAB -->
<div id="abc-tab" class="tab-panel hidden" style="margin-top:14px;">
  <div class="grid-main">
    <div>
      <div id="abc-champion-card" class="champion-card"></div>
    </div>
    <div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h2 style="margin:0;font-family:Orbitron;">AMERICAS BOXING COMMISSION</h2>
      </div>
      <div id="abc-rankings" class="rank-list"></div>
    </div>
  </div>
</div>



  <!-- CAF TAB -->
  <div id="caf-tab" class="tab-panel hidden" style="margin-top:14px;">
    <div class="grid-main">
      <div>
        <div id="caf-champion-card" class="champion-card"></div>
      </div>
      <div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <h2 style="margin:0;font-family:Orbitron;">UFL CAF TOP 30</h2>
        </div>
        <div id="caf-rankings" class="rank-list"></div>
      </div>
    </div>
  </div>

  <!-- PLAYERS TAB -->
  <div id="players-tab" class="tab-panel hidden" style="margin-top:14px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex-wrap:wrap;gap:8px;">
      <h2 style="margin:0;font-family:Orbitron;">PLAYERS</h2>
    
      <div style="display:flex;align-items:center;gap:8px;">
        <input id="players-search" placeholder="Search players..." oninput="renderPlayers()" />
        
        <select id="players-filter" class="input" style="padding:6px;" onchange="renderPlayers()">
          <option value="none">Filter: None</option>
          <option value="mostKO">Most KO/TKO</option>
          <option value="streak">Longest Winning Streak</option>
          <option value="active">Most Active</option>
          <option value="bonus">Most Bonuses (POTN/FOTN)</option>
          <option value="champion">Current Champions</option>
          <option value="formerChampion">Former Champions</option>
        </select>
    
        <button class="btn" onclick="renderPlayers()">Apply</button>
      </div>
    </div>

    <div class="players-header">
      <div class="players-columns">
        <div class="players-column-left">PLAYER NAME</div>
        
      </div>
    </div>

    <div id="players-list" style="max-height:640px; overflow:auto;"></div>
  </div>

  <!-- FIGHTS TAB -->
  <div id="fights-tab" class="tab-panel hidden" style="margin-top:14px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <h2 style="margin:0;font-family:Orbitron;">FIGHTS</h2>
      <div><input id="fights-search" placeholder="Search fights..." oninput="renderFights()" /><button class="btn" onclick="renderFights()">Search</button></div>
    </div>

  

    <div id="fights-list" style="max-height:640px; overflow:auto;"></div>
  </div>



  <!-- ADMIN TAB -->
  <div id="admin-tab" class="tab-panel hidden" style="margin-top:14px;">
    <div id="admin-login" class="frosted">
      <h3 style="margin:0;font-family:Orbitron;">Admin Login</h3>
      <div class="small-muted">Enter admin password to unlock admin tools. (fallback: <code>ufltest123</code>)</div>
      <div style="margin-top:10px;">
        <input id="admin-pass" type="password" placeholder="Admin password" />
        <div style="margin-top:8px;"><button class="btn btn-primary" onclick="attemptAdminLogin()">Login</button></div>
        <div id="admin-login-error" class="small-muted" style="color:#f87171;display:none;margin-top:8px;"></div>
      </div>
    </div>

    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
      <h2 style="margin:0;font-family:Orbitron;">Admin Dashboard</h2>
      <div style="display:flex;gap:8px;align-items:center;">
        <span class="small-muted">Logged in</span>
        <div style="display:flex;gap:8px;">
          <button class="btn btn-danger" onclick="logoutAdmin()">Logout</button>
        </div>
      </div>
    </div>
    
    <div id="admin-grid" style="display:grid; gap:12px;">
    
      <!-- ADD FIGHTER -->
      <div class="frosted">
        <h3 style="margin:0 0 8px 0;">Add Fighter</h3>
        <div class="small-muted">Add a new fighter to the roster with name and platform.</div>
        <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
          <input id="add-fighter-name" placeholder="Name" style="flex:1;" />
          <select id="add-fighter-platform"><option>PC</option><option>PS5</option><option>XBOX</option></select>
          <button class="btn btn-primary" onclick="adminAddFighter()">Add</button>
        </div>
      </div>
    
      <!-- ADD FIGHT -->
      <div class="frosted">
        <h3 style="margin:0 0 8px 0;">Add Fight</h3>
        <div class="small-muted">Enter new fight results for inclusion in rankings.</div>
        <div style="
          border:2px solid rgba(255,255,255,0.15);
          border-radius:12px;
          padding:16px;
          background:rgba(255,255,255,0.05);
          backdrop-filter:blur(6px);
          max-width:100%;
          display:flex;
          flex-direction:column;
          gap:10px;
        ">
          <label class="small-muted" for="add-fight-f1">FIGHTER 1</label>
          <select id="add-fight-f1" class="input" style="width:100%;"></select>
    
          <label class="small-muted" for="add-fight-f2">FIGHTER 2</label>
          <select id="add-fight-f2" class="input" style="width:100%;"></select>
    
          <label class="small-muted" for="add-fight-method">METHOD</label>
          <select id="add-fight-method" class="input" style="width:100%;">
            <option>KO/TKO</option>
            <option>Decision</option>
            <option>Draw</option>
          </select>
    
          <label class="small-muted" for="add-fight-winner">WINNER</label>
          <select id="add-fight-winner" class="input" style="width:100%;">
            <option value="0">Draw</option>
          </select>
    
          <label class="small-muted" for="add-fight-region">NA / EU</label>
          <select id="add-fight-region" class="input" style="width:100%;">
            <option value="NA">NA</option>
            <option value="EU">EU</option>
          </select>
    
          <label class="small-muted" for="add-fight-caf">CAF: YES OR NO</label>
          <select id="add-fight-caf" class="input" style="width:100%;">
            <option value="false">No</option>
            <option value="true">Yes</option>
          </select>

          <!-- BONUS AWARD -->
<label class="small-muted" for="add-fight-bonus">BONUS AWARD</label>
<select id="add-fight-bonus" class="input" style="width:100%;">
  <option value="none">None</option>
  <option value="POTN">POTN</option>
  <option value="FOTN">FOTN</option>
</select>

<!-- TITLE FIGHT -->
<label class="small-muted" for="add-fight-title">TITLE FIGHT</label>
<select id="add-fight-title" class="input" style="width:100%;">
  <option value="none">None</option>
  <option value="UFL WORLD">UFL World Title</option>
  <option value="RBC">RBC Title</option>
  <option value="ABC">ABC Title</option>
  <option value="UFL CAF">UFL CAF Title</option>
</select>
    
          <label class="small-muted" for="add-fight-date">DATE</label>
          <input id="add-fight-date" type="date" class="input" style="width:100%;" />
    
          <button class="btn btn-primary" style="margin-top:12px;" onclick="adminAddFight()">Add Fight</button>
        </div>
      </div>
    
      <!-- MANAGE FIGHTER -->
      <div class="frosted" style="grid-column:span 2;">
        <h3 style="margin:0 0 8px 0;">Manage Fighters</h3>
        <div class="small-muted">Edit names, platform, retire/unretire. Points column shows current ranking points.</div>
        <div style="margin-top:8px;">
          <table>
            <thead><tr><th>Name</th><th>Platform</th><th>Record</th><th>Points</th><th>Actions</th></tr></thead>
            <tbody id="admin-fighters-list"></tbody>
          </table>
        </div>
      </div>
    
      <!-- MANAGE FIGHT -->
      <div class="frosted" style="grid-column:span 2;">
        <h3 style="margin:0 0 8px 0;">Manage Fights</h3>
        <div class="small-muted">Select an existing fight to edit or delete (admin only).</div>
        <div style="margin-top:8px;">
          <select id="admin-fights-dropdown" style="width:100%;padding:8px;border-radius:6px;"></select>
          <div style="margin-top:8px;display:flex;gap:8px;">
            <button class="btn btn-primary" onclick="adminEditSelectedFight()">Edit Selected</button>
            <button class="btn btn-danger" onclick="adminDeleteSelectedFight()">Delete Selected</button>
          </div>
          <div id="admin-fights-list" style="margin-top:10px;max-height:240px;overflow:auto;"></div>
        </div>
      </div>
    
      <!-- CHAMPION TITLES -->
      <div class="frosted" style="grid-column:span 2;border:2px solid rgba(255,255,255,0.15);border-radius:12px;padding:16px;background:rgba(255,255,255,0.05);backdrop-filter:blur(6px);margin-top:12px;">
        <h3 style="margin:0 0 8px 0;">Champion Titles Management</h3>
        <div class="small-muted">Assign UFL, RBC, ABC, and CAF titles. Vacate clears title and resets counters.</div>
        <div id="champion-titles-container" style="margin-top:10px;display:grid;grid-template-columns:1fr 1fr;gap:10px;"></div>
        <div style="margin-top:10px;display:flex;gap:8px;">
          <button class="btn btn-yellow" onclick="saveChampionAssignments()">Save Titles</button>
          <button class="btn" onclick="resetChampionAssignments()">Clear Titles</button>
          <button class="btn" onclick="refreshRankings()">üîÑ Refresh Rankings</button>
        </div>
    
        <!-- RANKING BREAKDOWN -->
        <div class="breakdown" id="ranking-breakdown" style="margin-top:14px;">
          <div style="font-weight:700;color:var(--gold);margin-bottom:6px;">RANKING POINTS BREAKDOWN</div>
          <div>- <strong>Base Points:</strong> +3 for a Win, ‚àí1.5 for a Loss, +1 for a Draw</div>
          <div>- <strong>Contender Multiplier:</strong> √ó1.25 for fights where both are ranked Top 10</div>
          <div>- <strong>Opponent Strength Bonus:</strong> Weighted by opponent‚Äôs win percentage</div>
          <div>- <strong>Recency Bonus:</strong> √ó1.2 for fights within the last 10 days</div>
          <div>- <strong>Activity Decay:</strong> Fighters inactive for 20+ days lose 1% per day (up to ‚àí20%).</div>
        </div>
    
        <!-- BADGE BREAKDOWN -->
        <div style="margin-top:20px;">
          <div style="font-weight:700;color:var(--gold);margin-bottom:6px;">BADGE SYSTEM BREAKDOWN</div>
          <div>- üèõÔ∏è <strong>ICON:</strong> 10+ total fights and a win rate of 80% or higher.<br>
            
          </div>
          <div>- üî• <strong>WINNING STREAK:</strong> Currently on a win streak (1+ consecutive wins).<br>
            
          </div>
          <div>- ü•ä <strong>KO ARTIST:</strong> 8+ total fights and at least 4 KO/TKO victories.<br>
           
          </div>
          <div>- ‚öôÔ∏è <strong>WORKHORSE:</strong> 3+ fights within any 10-day span.<br>
            
          </div>
          <div>- üåü <strong>RISING STAR:</strong> Fewer than 8 total fights and a win rate of 80% or higher.<br>
            
          </div>
    </div>
    
  </div>
</div>


        
      </div>
    </div>
  </div>
</div><!-- frosted -->
</div><!-- container -->

<!-- Fighter modal -->
<div id="fighter-modal" class="hidden modal-backdrop" aria-hidden="true">
<div class="modal" id="fighter-modal-content" style="max-width:900px;">
  <!-- content filled dynamically -->
</div>
</div>

<!-- Edit fight modal (admin) -->
<div id="edit-fight-modal" class="hidden modal-backdrop" aria-hidden="true">
<div class="modal" style="max-width:520px;">
  <div style="display:flex;justify-content:space-between;align-items:center;">
    <h3 style="margin:0;font-family:Orbitron;">Edit Fight</h3>
    <button class="btn" onclick="closeEditFightModal()">‚úñ</button>
  </div>
  
  <div style="
  border:2px solid rgba(255,255,255,0.15);
  border-radius:12px;
  padding:16px;
  background:rgba(255,255,255,0.05);
  backdrop-filter:blur(6px);
  display:flex;
  flex-direction:column;
  gap:10px;
  margin-top:12px;
">

  <!-- PLATFORM -->
  <label class="small-muted" for="edit-fight-platform">PLATFORM</label>
  <select id="edit-fight-platform" class="input" style="width:100%;">
    <option>PC</option>
    <option>PS5</option>
    <option>XBOX</option>
  </select>

  <!-- FIGHTER 1 -->
  <label class="small-muted" for="edit-fight-f1">FIGHTER 1</label>
  <select id="edit-fight-f1" class="input" style="width:100%;"></select>

  <!-- FIGHTER 2 -->
  <label class="small-muted" for="edit-fight-f2">FIGHTER 2</label>
  <select id="edit-fight-f2" class="input" style="width:100%;"></select>

  <!-- METHOD -->
  <label class="small-muted" for="edit-fight-method">METHOD</label>
  <select id="edit-fight-method" class="input" style="width:100%;">
    <option>KO/TKO</option>
    <option>Decision</option>
    <option>Draw</option>
  </select>

  <!-- WINNER -->
  <label class="small-muted" for="edit-fight-winner">WINNER</label>
  <select id="edit-fight-winner" class="input" style="width:100%;">
    <option value="0">Draw</option>
  </select>

  <!-- REGION -->
  <label class="small-muted" for="edit-fight-region">NA / EU</label>
  <select id="edit-fight-region" class="input" style="width:100%;">
    <option value="NA">NA</option>
    <option value="EU">EU</option>
  </select>

  <!-- CAF -->
  <label class="small-muted" for="edit-fight-caf">CAF: YES OR NO</label>
  <select id="edit-fight-caf" class="input" style="width:100%;">
    <option value="false">No</option>
    <option value="true">Yes</option>
  </select>



  <!-- DATE -->
  <label class="small-muted" for="edit-fight-date">DATE</label>
  <input id="edit-fight-date" type="date" class="input" style="width:100%;" />

  <!-- BUTTONS -->
  <div style="display:flex;justify-content:space-between;margin-top:14px;">
    <button class="btn btn-danger" onclick="confirmDeleteFight()">Delete</button>
    <button class="btn btn-primary" onclick="saveEditedFight()">Save Changes</button>
  </div>

  </div>
</div>
</div>
<!-- END Part 2 of 6 -->
<!-- START Part 3 of 6 -->
<script>
  /* ===========================
   üî• FIREBASE INITIALIZATION
   =========================== */

const firebaseConfig = {
  apiKey: "AIzaSyBkcyte__qrs-sxQilqjK40Wl5NDJARxzU",
  authDomain: "ufl-season-3.firebaseapp.com",
  projectId: "ufl-season-3",
  storageBucket: "ufl-season-3.firebasestorage.app",
  messagingSenderId: "148274309173",
  appId: "1:148274309173:web:335fbe2161af38f9c6e97c"
};

// ‚úÖ Initialize Firebase (compat syntax)
const app = firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

  
  /* ===========================
     üåê GLOBAL STATE & HELPERS
     =========================== */
  let fighters = [];   // raw fighter docs from Firestore
  let fights = [];     // raw fight docs from Firestore
  let champions = {};  // champion assignments from settings/champions doc
  
  const TITLES = [
    "UFL World Champion","UFL CAF Champion",
    "UFL PC Champion","UFL PS5 Champion","UFL Xbox Champion",
    "RBC PC Champion","RBC PS5 Champion","RBC Xbox Champion"
  ];
  
  const $ = id => document.getElementById(id);
  const escapeHtml = s => !s ? '' : String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  const formatDateShort = iso => {
    if(!iso) return 'N/A';
    try {
      const d = new Date(iso);
      const mm = (d.getMonth()+1).toString().padStart(2,'0');
      const dd = d.getDate().toString().padStart(2,'0');
      const yy = d.getFullYear().toString().slice(-2);
      return `${mm}/${dd}/${yy}`;
    } catch(e) { return 'N/A'; }
  };
  
  /* ===========================
     üîÅ FIRESTORE LISTENERS
     =========================== */
  
  db.collection('fighters').onSnapshot(snap=>{
    fighters = snap.docs.map(d => ({ id: d.id, ...d.data() }));
    // normalize expected fields
    fighters.forEach(f=>{
      f.wins = f.wins || 0;
      f.losses = f.losses || 0;
      f.draws = f.draws || 0;
      f.koWins = f.koWins || 0;
      f.retired = !!f.retired;
      f.platform = f.platform || '';
      // convenience totals (kept for rendering, recalculated in recomputeAllFighterStats when needed)
      f.totalFights = (f.wins + f.losses + f.draws) || 0;
    });
    // update any UI selects / lists that depend on fighters
    populateEditFightSelects?.();
    populateChampionTitleSelects?.();
    populateAdminFighters?.();
    renderAll?.();
  }, e=>console.error('fighters listener error', e));

// üß© Track former champions globally
let formerChampions = [];

async function updateFormerChampions() {
  formerChampions = [];

  fights.forEach(f => {
    if (f.title && f.title !== 'none') {
      if (f.winner && f.winner !== '0') {
        const loser = (f.winner === f.fighter1) ? f.fighter2 : f.fighter1;
        if (!formerChampions.includes(loser)) {
          formerChampions.push(loser);
        }
      }
    }
  });

  // ‚úÖ Persist list to Firestore
  try {
    await db.collection('settings').doc('formerChampions').set(
      { list: formerChampions },
      { merge: true }
    );
  } catch (e)
    console.error('Failed to save formerChampions:', e);
  }

  // Optional debug log (silent in production)
  if (window.location.hostname.includes('localhost')) {
    console.log('Former champions list updated:', formerChampions);
  }
}


  // üß© Save to Firestore so it's persistent
  db.collection('settings').doc('formerChampions').set(
    { list: formerChampions },
    { merge: true }
  ).catch(e => console.error('Failed to update former champions list', e));
}


// ===========================
// ü•ä FIGHTS SNAPSHOT LISTENER
// ===========================
db.collection('fights').orderBy('date','desc').onSnapshot(snap=>{
  fights = snap.docs.map(d=>({ id:d.id, ...d.data() }));

  // ensure consistent fields
  fights.forEach(f=>{
f.platform = f.platform || '';
f.method = f.method || '';
f.caf = !!f.caf;
f.bonus = f.bonus || ''; // ‚úÖ ensures every fight has a bonus field

    // store human readable fighter names (for older entries)
    f.fighter1Name = f.fighter1Name || (fighters.find(x=>x.id===f.fighter1)?.name || '');
    f.fighter2Name = f.fighter2Name || (fighters.find(x=>x.id===f.fighter2)?.name || '');
    f.winnerName = (f.winner === '0' || f.winner === 0)
      ? 'Draw'
      : (fighters.find(x=>x.id===f.winner)?.name || '');
  });

  // ‚úÖ Add this line to actually build the list!
  updateFormerChampions();

  populateEditFightSelects?.();
  recomputeTitleDefensesFromFights?.();
  renderAll?.();

}, e=>console.error('fights listener error', e));


// =============================
// üëë CHAMPIONS SNAPSHOT LISTENER
// =============================
db.collection('settings').doc('champions').onSnapshot(doc=>{
  champions = doc.exists ? doc.data() : {};

  // normalize fields we expect
  champions.uflWorld = champions.uflWorld || null;
  champions.uflWorldDefenses = champions.uflWorldDefenses || 0;
  champions.uflWorldLastDefense = champions.uflWorldLastDefense || '';
  champions.uflCAF = champions.uflCAF || null;
  champions.uflCAFDefenses = champions.uflCAFDefenses || 0;
  champions.uflCAFLastDefense = champions.uflCAFLastDefense || '';
  champions.uflPC = champions.uflPC || null;
  champions.uflPS5 = champions.uflPS5 || null;
  champions.uflXbox = champions.uflXbox || null;
  champions.rbcPC = champions.rbcPC || null;
  champions.rbcPS5 = champions.rbcPS5 || null;
  champions.rbcXbox = champions.rbcXbox || null;
  champions.youtubePlaylist = champions.youtubePlaylist || '';

  populateChampionTitleSelects?.();
  renderAll?.();
}, e=>console.warn('champions listener', e));

// üèÜ Listen for former champions list (persistent version)
db.collection('settings').doc('formerChampions').onSnapshot(doc => {
  formerChampions = (doc.exists && doc.data().list) ? doc.data().list : [];
  if (window.location.hostname.includes('localhost')) {
    console.log('Loaded formerChampions from Firestore:', formerChampions);
  }
}, e => console.warn('formerChampions listener error', e));




// =============================
// üîê ADMIN PASSWORD FETCH
// =============================
db.collection('settings').doc('admin').get().then(doc=>{
  if(doc.exists) window.ADMIN_PW = doc.data().password || null;
}).catch(()=>{ window.ADMIN_PW = null; });


  /* ===========================
     üß© COMBINE FIGHTER DATA (same names across platforms)
     =========================== */
  /*
    Returns an array of combined fighter objects:
    {
      name: 'PlayerName',
      ids: [ 'fighterDocIdPC','fighterDocIdPS5' ],
      wins, losses, draws, koWins,
      totalFights, retiredAll, isCAFAny,
      points (calculated later), lastFightDate, idMain (first id)
    }
  */
  /* ============================================================
   üîó Combine fighters across platforms by identical name
   ============================================================ */
function buildCombinedMap() {
  // if fighters array not yet loaded, return empty
  if (!fighters || !Array.isArray(fighters) || fighters.length === 0) return [];

  const combinedMap = {};

  fighters.forEach(f => {
    if (!f || !f.name) return;

    const key = f.name.trim().toLowerCase();

    if (!combinedMap[key]) {
      combinedMap[key] = {
        name: f.name.trim(),
        ids: [],
        isCAFAny: false,
        wins: 0,
        losses: 0,
        draws: 0,
        koWins: 0,
        idMain: f.id,
        points: 0
      };
    }

    const current = combinedMap[key];
    current.ids.push(f.id);
    current.isCAFAny = current.isCAFAny || !!f.isCAF;
    current.wins += parseInt(f.wins || 0);
    current.losses += parseInt(f.losses || 0);
    current.draws += parseInt(f.draws || 0);
    current.koWins += parseInt(f.koWins || 0);
  });

  // return sorted array to maintain consistency
  return Object.values(combinedMap).sort((a, b) => a.name.localeCompare(b.name));
}

  
  /* ===========================
     üî• STREAKS, WINS/LOSSES, BADGES
     =========================== */
  
  /* Compute hot/cold/neutral streak (for UI dot) */
  function computeStreakForCombined(ids, lookback=5){
    const relevant = fights.filter(f=> ids.includes(f.fighter1) || ids.includes(f.fighter2))
      .slice().sort((a,b)=> new Date(b.date) - new Date(a.date));
    if(!relevant.length) return 'neutral';
    let outcomes = [];
    for(let f of relevant){
      if(outcomes.length >= lookback) break;
      if(f.winner === '0' || f.winner === 0){ outcomes.push('D'); continue; }
      if(ids.includes(f.winner)) outcomes.push('W'); else outcomes.push('L');
    }
    if(outcomes.length === 0) return 'neutral';
    if(outcomes.slice(0,3).every(o=>o==='W')) return 'hot';
    if(outcomes.slice(0,3).every(o=>o==='L')) return 'cold';
    return 'neutral';
  }
  
  /* Count consecutive losses (most recent first) used for escalation penalty */
  function countConsecutiveLosses(ids){
    const relevant = fights.filter(f=> ids.includes(f.fighter1) || ids.includes(f.fighter2))
      .slice().sort((a,b)=> new Date(b.date) - new Date(a.date));
    let count = 0;
    for(const f of relevant){
      if(f.winner === '0' || f.winner === 0) break;
      if(f.winner && ids.includes(f.winner)) break; // win encountered -> stop
      if(f.winner && !ids.includes(f.winner)) count++;
    }
    return count;
  }
  
  /* Count consecutive wins (most recent first) */
  function countConsecutiveWins(ids){
    const relevant = fights.filter(f=> ids.includes(f.fighter1) || ids.includes(f.fighter2))
      .slice().sort((a,b)=> new Date(b.date) - new Date(a.date));
    let count = 0;
    for(const f of relevant){
      if(f.winner === '0' || f.winner === 0) break;
      if(f.winner && ids.includes(f.winner)) count++; else break;
    }
    return count;
  }
  
  /* Compute badges for a combined fighter (ordered by priority) */
  function computeBadgesForCombined(ids) {
  const combinedList = buildCombinedMap();
  const combined = combinedList.find(c => c.ids.some(id => ids.includes(id)));
  if (!combined) return [];

  const totalFights = (combined.wins + combined.losses + combined.draws) || 0;
  const winPct = totalFights > 0 ? (combined.wins / totalFights) : 0;
  const badges = [];

  // üèõÔ∏è ICON BADGE ‚Äî 10+ fights and 80%+ win rate
  if (totalFights >= 10 && winPct >= 0.8) {
    badges.push({ key: 'Icon', icon: 'üèõÔ∏è', desc: 'Icon' });
  }

  // üî• WINNING STREAK
  const streakLen = countConsecutiveWins(ids);
  if (streakLen >= 1) {
    badges.push({ key: 'Winning Streak', icon: 'üî•', desc: `Current win streak: ${streakLen}` });
  }

  // ü•ä KO ARTIST ‚Äî 8+ fights and 4+ KO/TKO wins
  if (totalFights >= 8 && combined.koWins >= 4) {
    badges.push({ key: 'KO Artist', icon: 'ü•ä', desc: 'KO Artist' });
  }

 
// helper to safely convert Firestore timestamps or strings to Date
function safeDate(d) {
  if (!d) return null;
  if (d instanceof Date) return d;
  if (typeof d === 'object' && d.seconds) return new Date(d.seconds * 1000);
  return new Date(d);
}

  // ‚öôÔ∏è WORKHORSE ‚Äî 3+ fights in 10-day window
  let workhorse = false;
  const relevant = fights.filter(f => ids.includes(f.fighter1) || ids.includes(f.fighter2)).slice();
  for (let i = 0; i < relevant.length; i++) {
    const d1 = new Date(relevant[i].date);
    const windowStart = new Date(d1);
    windowStart.setDate(windowStart.getDate() - 10);
    const count = relevant.filter(f => {
      const d = new Date(f.date);
      return d >= windowStart && d <= d1;
    }).length;
    if (count >= 3) {
      workhorse = true;
      break;
    }
  }
  if (workhorse) {
    badges.push({ key: 'Workhorse', icon: '‚öôÔ∏è', desc: 'Workhorse ‚Äî 3+ fights in 10 days' });
  }


  

  // üåü RISING STAR ‚Äî <8 fights and 80%+ win rate
  if (totalFights < 8 && winPct >= 0.8 && totalFights > 0) {
    badges.push({ key: 'Rising Star', icon: 'üåü', desc: 'Rising Star' });
  }

     // üèÖ PERFORMANCE OF THE NIGHT (POTN)
  const potnCount = fights.filter(f =>
    (ids.includes(f.fighter1) || ids.includes(f.fighter2)) && f.bonus === 'POTN'
  ).length;
  if (potnCount > 0) {
    badges.push({
      key: 'POTN',
      icon: 'üí∞',
      desc: `Performance of the Night √ó${potnCount}`
    });
  }

  // ü•á FIGHT OF THE NIGHT (FOTN)
  const fotnCount = fights.filter(f =>
    (ids.includes(f.fighter1) || ids.includes(f.fighter2)) && f.bonus === 'FOTN'
  ).length;
  if (fotnCount > 0) {
    badges.push({
      key: 'FOTN',
      icon: 'üí∞',
      desc: `Fight of the Night √ó${fotnCount}`
    });
  }

  // üëë CHAMPION / FORMER CHAMPION BADGES
  ¬†¬†const fighterIdMatch = id => ids.includes(id);

¬†¬†// Gather all title fights this fighter has participated in
¬†¬†const titleFights = fights.filter(f =>
¬†¬†¬†¬†f.title && f.title !== 'none' &&
¬†¬†¬†¬†(fighterIdMatch(f.fighter1) || fighterIdMatch(f.fighter2))
¬†¬†);

¬†¬†const currentChampionTitles = [];
¬†¬†const formerChampionTitles = [];

¬†¬†// Determine which titles they‚Äôve won or lost
¬†¬†for (const f of titleFights) {
¬†¬†¬†¬†if (f.winner && f.winner !== '0') {
¬†¬†¬†¬†¬†¬†const isWinner = fighterIdMatch(f.winner);
¬†¬†¬†¬†¬†¬†if (isWinner) {
¬†¬†¬†¬†¬†¬†¬†¬†currentChampionTitles.push(f.title);
¬†¬†¬†¬†¬†¬†} else {
¬†¬†¬†¬†¬†¬†¬†¬†formerChampionTitles.push(f.title);
¬†¬†¬†¬†¬†¬†}
¬†¬†¬†¬†}
¬†¬†}

¬†¬†// Remove duplicates
¬†¬†const uniqueCurrentTitles = [...new Set(currentChampionTitles)];
¬†¬†const uniqueFormerTitles = [...new Set(formerChampionTitles)];

¬†¬†// Build defense history (optional hover details)
¬†¬†const defenseInfo = [];

¬†¬†fights
¬†¬†¬†¬†.filter(f => f.title && f.title !== 'none' && f.winner && fighterIdMatch(f.winner))
¬†¬†¬†¬†.forEach(f => {
¬†¬†¬†¬†¬†¬†const opponentId = f.fighter1 === f.winner ? f.fighter2 : f.fighter1;
¬†¬†¬†¬†¬†¬†const opponentName = fighters.find(x => x.id === opponentId)?.name || 'Unknown';
¬†¬†¬†¬†¬†¬†const date = f.date ? formatDateShort(f.date) : 'N/A';
¬†¬†¬†¬†¬†¬†defenseInfo.push(`${opponentName} (${date})`);
¬†¬†¬†¬†});

¬†¬†// Assign Champion / Former Champion badges
¬†¬†if (uniqueCurrentTitles.length > 0) {
¬†¬†¬†¬†const titleList = uniqueCurrentTitles.join(', ');
¬†¬†¬†¬†const defenseText = defenseInfo.length ? ` | Defenses: ${defenseInfo.join(', ')}` : '';
¬†¬†¬†¬†badges.push({
¬†¬†¬†¬†¬†¬†key: 'Champion',
¬†¬†¬†¬†¬†¬†icon: 'üëë',
¬†¬†¬†¬†¬†¬†desc: `Current ${titleList} Champion${defenseText}`
¬†¬†¬†¬†});
¬†¬†} else if (uniqueFormerTitles.length > 0) {
¬†¬†¬†¬†const titleList = uniqueFormerTitles.join(', ');
¬†¬†¬†¬†badges.push({
¬†¬†¬†¬†¬†¬†key: 'FormerChampion',
¬†¬†¬†¬†¬†¬†icon: 'ü•à',
¬†¬†¬†¬†¬†¬†desc: `Former ${titleList} Champion`
¬†¬†¬†¬†});
¬†¬†}

  // Order badges logically by importance
  const order = ['Icon', 'Champion', 'Winning Streak', 'KO Artist', 'Workhorse', 'Rising Star', 'POTN', 'FOTN'];
  badges.sort((a, b) => order.indexOf(a.key) - order.indexOf(b.key));

  return badges;
}

  
  
  /* Recompute title defenses from fights (updates champions.*Defenses and last defense in memory only)
     Note: this function computes counts locally; saving to Firestore is done via the admin UI save function.
  */
  function recomputeTitleDefensesFromFights(){
    // reset counters
    let worldDefenses = 0, cafDefenses = 0;
    let worldLast = '', cafLast = '';
  
    // for each fight, if champion participated and champion won and fight has a date -> count as defense
    fights.forEach(f=>{
      if(!f.date) return;
      if(champions.uflWorld && (f.fighter1 === champions.uflWorld || f.fighter2 === champions.uflWorld)){
        if(f.winner === champions.uflWorld) {
          worldDefenses++;
          if(!worldLast || new Date(f.date) > new Date(worldLast)) worldLast = f.date;
        }
      }
      if(champions.uflCAF && (f.fighter1 === champions.uflCAF || f.fighter2 === champions.uflCAF)){
        if(f.winner === champions.uflCAF) {
          cafDefenses++;
          if(!cafLast || new Date(f.date) > new Date(cafLast)) cafLast = f.date;
        }
      }
    });
  
    // update local champions object (not writing to Firestore automatically)
    champions.uflWorldDefenses = worldDefenses;
    champions.uflWorldLastDefense = worldLast || champions.uflWorldLastDefense || '';
    champions.uflCAFDefenses = cafDefenses;
    champions.uflCAFLastDefense = cafLast || champions.uflCAFLastDefense || '';
  }
  
  /* Export some helpers for other parts */
  window.buildCombinedMap = buildCombinedMap;
  window.computeStreakForCombined = computeStreakForCombined;
  window.countConsecutiveWins = countConsecutiveWins;
  window.countConsecutiveLosses = countConsecutiveLosses;
  window.computeBadgesForCombined = computeBadgesForCombined;
  window.recomputeTitleDefensesFromFights = recomputeTitleDefensesFromFights;
  </script>
  <!-- END Part 3 of 6 -->
<!-- START Part 4 of 6 -->
<script>
  /* ========================================================
     üßÆ RANKING ALGORITHM ‚Äî includes multipliers & decay
     ======================================================== */
  
  /*
   Scoring summary (you requested):
    - Win = +3 points
    - Loss = -2 points (escalates by ‚àí0.25 per consecutive loss)
    - Draw = +1 point
    - Title Capture = +2
    - Title Defense = +3
    - Championship fight multiplier = √ó1.5
    - Defense fight multiplier = √ó1.5
    - Contender multiplier = √ó1.25 (both top 10)
    - Recency bonus: √ó1.2 for fights within 10 days
    - Decay: lose 1% per day inactive after 10 days (max ‚àí20%)
  */
  
  // ---------------------------------------------
// üìÖ Utility: Days Between Dates
// ---------------------------------------------
function daysBetween(d1, d2) {
  try {
    const date1 = new Date(d1), date2 = new Date(d2);
    const diff = (date2 - date1) / (1000 * 60 * 60 * 24);
    return Math.floor(diff);
  } catch {
    return 999;
  }
}

// ---------------------------------------------
// üßÆ Main Ranking Calculator
// ---------------------------------------------
function calculateRankPoints(fighterIds, returnBreakdown = false) {
  // --- Breakdown trackers (for Player Card)
  let breakdown = {
    base: 0,
    finish: 0,
    opponent: 0,
    recency: 0,
    streak: 0,
    contender: 0,
    modifiers: 0
  };

  const now = new Date();
  const combined = (typeof buildCombinedMap === 'function') ? buildCombinedMap() : [];
  const combinedFights = fights.filter(
    f => fighterIds.includes(f.fighter1) || fighterIds.includes(f.fighter2)
  );

  if (combinedFights.length === 0) return returnBreakdown ? { ...breakdown, total: 0 } : 0;

  let points = 0;
  const consecutiveLosses = countConsecutiveLosses(fighterIds);
  const lossPenalty = 1.5 + (0.5 * Math.max(0, consecutiveLosses - 1));

  combinedFights.forEach(f => {
    let base = 0;
    let bonus = 0;
    let multiplier = 1.0;

    const isWin = fighterIds.includes(f.winner);
    const isDraw = f.winner === '0' || f.winner === 0;
    const isLoss = !isWin && !isDraw;

    const f1Rank = getCurrentRank(f.fighter1);
    const f2Rank = getCurrentRank(f.fighter2);
    const selfRank = fighterIds.includes(f.fighter1) ? f1Rank : f2Rank;
    const oppRank = fighterIds.includes(f.fighter1) ? f2Rank : f1Rank;
    const rankDiff = Math.abs(selfRank - oppRank);

    // üèÜ Base system
    if (isWin) base += 3;
    if (isLoss) base -= lossPenalty;
    if (isDraw) base += 1;
    breakdown.base += base;

// ü•ä KO/TKO Finish Bonus
if (isWin && f.method && /ko|tko/i.test(f.method)) {
  base += 1; // small bonus
  breakdown.finish += 1; // track in modifiers or create a separate "finishBonus" if you prefer
}

    // üß© Rank differential adjustment
    if (isWin && selfRank > oppRank) {
      bonus += Math.min(rankDiff * 0.05, 1);
    } else if (isLoss && selfRank < oppRank) {
      bonus -= Math.min(rankDiff * 0.025, 0.5);
    }
    breakdown.modifiers += bonus;

    // üí™ Opponent Strength (combined record)
    const mainFighter = fighterIds[0];
    const oppId = fighterIds.includes(f.fighter1) ? f.fighter2 : f.fighter1;
    const oppCombined = combined.find(c => c.ids.includes(oppId));
    let oppStrengthBonus = 0;

    if (oppCombined) {
      const totalFights = oppCombined.wins + oppCombined.losses + oppCombined.draws;
      if (totalFights > 0) {
        const oppWinPct = oppCombined.wins / totalFights;
        oppStrengthBonus = (oppWinPct - 0.5) * 3; // slightly stronger weighting
        if (f.winner === mainFighter && oppStrengthBonus < 0) oppStrengthBonus = 0; // never penalize win
        oppStrengthBonus = Math.max(-2, Math.min(oppStrengthBonus, 2)); // cap
        base += oppStrengthBonus;
        breakdown.opponent += oppStrengthBonus;
      }
    }
    // üîù Contender Fight Bonus (Top 10 vs Top 10)
// üîù Contender Fight Bonus (Top 10 involvement)
if (f1Rank <= 10 || f2Rank <= 10) {
  multiplier *= 1.15;
  breakdown.contender += (base + bonus) * 0.15; // üÜï track separately

}



    // ‚è± Recency bump (within 10 days)
    const daysSince = daysBetween(f.date, now);
   
    
    if (daysSince <= 20) { // or 10 depending on your threshold
  multiplier *= 1.15;
  breakdown.recency += Math.max(0, (base + bonus) * 0.15);
 // record approximate bonus
}

    points += (base + bonus) * multiplier;
  });

  // üß® Win streak momentum bonus
  const streak = countConsecutiveWins(fighterIds);
  if (streak >= 3) {
    const streakBonus = Math.min((streak - 2) * 1, 5);
    points += streakBonus;
    breakdown.streak += streakBonus;
  }

  // üßÆ Inactivity decay
const lastFight = combinedFights.length
  ? new Date(Math.max(...combinedFights.map(f => new Date(f.date))))
  : null;

if (lastFight) {
  const inactiveDays = daysBetween(lastFight, now);
  if (inactiveDays > 20) {
    const decayRate = Math.min((inactiveDays - 20) * 0.005, 0.15);
    
    // üß† Track the decay penalty for Ranking Breakdown
    const decayLoss = points * decayRate;
    breakdown.modifiers -= decayLoss; // record decay as a negative impact

    points *= (1 - decayRate);
  }

  }

  // üëë (Optional) Champion bonuses ‚Äî currently disabled
  // const championKeys = [
  //   'uflWorld', 'uflCAF', 'uflPC', 'uflPS5', 'uflXbox',
  //   'rbcPC', 'rbcPS5', 'rbcXbox'
  // ];
  // for (const key of championKeys) {
  //   if (champions[key] && fighterIds.includes(champions[key])) {
  //     points += 10;
  //     breakdown.modifiers += 10;
  //   }
  // }

// ‚úÖ Final breakdown + return
breakdown.total = Math.round(points);

if (returnBreakdown) {
  return breakdown;
}

return breakdown.total;

}

// ---------------------------------------------
// üìä Helpers & Ranking Render Pipeline
// ---------------------------------------------
function getCurrentRank(fid) {
  const all = buildCombinedMap();
  const ranked = all.sort((a, b) => b.points - a.points);
  const index = ranked.findIndex(r => r.ids.includes(fid));
  return index >= 0 ? index + 1 : 999;
}

function computeRankings() {
  // Existing code that builds fighter list and calculates points
  const allRanked = fighters
    .filter(f => !f.retired)
    .map(f => {
      f.points = calculateRankPoints(f.id);
      return f;
    })
    .sort((a, b) => b.points - a.points);

  // üåé WORLD = All fights
  const world = [...allRanked].slice(0, 30);

  // üß¨ CAF = fighters who have CAF fights
  const caf = allRanked
    .filter(f => f.isCAFAny)
    .slice(0, 30);

  // üá∫üá∏ ABC = North America
  const abc = allRanked.filter(f =>
    fights.some(x =>
      x.region === 'NA' && (x.fighter1 === f.id || x.fighter2 === f.id)
    )
  ).slice(0, 15);

  // üá™üá∫ RBC = Europe
  const rbc = allRanked.filter(f =>
    fights.some(x =>
      x.region === 'EU' && (x.fighter1 === f.id || x.fighter2 === f.id)
    )
  ).slice(0, 15);

  return { world, caf, abc, rbc };
}



}

function renderAll() {
  const { world, caf, abc, rbc } = computeRankings();

renderRankings(world, 'world-rankings');
renderRankings(caf, 'caf-rankings');
renderRankings(abc, 'abc-rankings');
renderRankings(rbc, 'rbc-rankings');

// üèÜ Champion cards
renderChampion('world-champion-card', champions?.uflWorld);
renderChampion('caf-champion-card', champions?.uflCAF);
renderChampion('abc-champion-card', champions?.abc);
renderChampion('rbc-champion-card', champions?.rbc);

}

function refreshRankings() {
  renderAll();
  alert('Rankings refreshed!');
}
  </script>
  <!-- END Part 4 of 6 -->
<!-- START Part 5 of 6 -->
<script>
  /* ============================================================
     üèÜ  RENDERING ‚Äî Champion cards, Rankings, Fighters, Modals
     ============================================================ */
  
  /* Floating Champion Card with gold crown icon */
  function renderChampionCard(type, container) {
  const field = type === 'world' ? 'uflWorld' : 'uflCAF';
  const champId = champions?.[field];
  const champData = fighters.find(f => f.id === champId);
  const title = type === 'world' ? 'UFL WORLD CHAMPION' : 'UFL CAF CHAMPION';
  const defenses = type === 'world' ? (champions.uflWorldDefenses || 0) : (champions.uflCAFDefenses || 0);
  const lastDefense = type === 'world' ? champions.uflWorldLastDefense : champions.uflCAFLastDefense;

  // üßÆ Get combined record across platforms
  let recordText = '';
  if (champData) {
    const combinedList = buildCombinedMap();
    const combinedEntry = combinedList.find(c => c.ids.includes(champData.id));
    const wins = combinedEntry ? combinedEntry.wins : champData.wins || 0;
    const losses = combinedEntry ? combinedEntry.losses : champData.losses || 0;
    const draws = combinedEntry ? combinedEntry.draws : champData.draws || 0;
    recordText = `${wins}-${losses}-${draws}`;
  }

  container.innerHTML = `
    <div class="champion-card floating-card">
      <div class="champion-header">
        <i class="fas fa-crown champion-crown"></i>
        <h2 class="champion-title">${title}</h2>
      </div>
      <div class="champion-body">
        ${
          champData
            ? `<h3 class="champion-name clickable" onclick="openFighterModal('${champData.id}')">${escapeHtml(champData.name)}</h3>`
            : `<h3 class="champion-name vacant">VACANT</h3>`
        }
        ${
          champData
            ? `<p class="champion-record">Record: <strong>${recordText}</strong></p>`
            : ''
        }
        <p class="champion-details">
          ${defenses > 0 ? `<span class="champion-defenses">${defenses} Defense${defenses > 1 ? 's' : ''}</span>` : ''}
        </p>
        ${lastDefense ? `<p class="champion-last-defense">Last Defense: ${formatDateShort(lastDefense)}</p>` : ''}
      </div>
    </div>`;
}

  
  /* Rank list with numbers & small platform-champ icons */
  function renderRankings(list, containerId) {
    const container = $(containerId);
    if (!container) return;
    container.innerHTML = '';
    list.forEach((f, i) => {
      const rankNum = i + 1;
      const champIcons = getChampionIcons(f);
      container.insertAdjacentHTML('beforeend', `
        <div class="fighter-row" onclick="openFighterModal('${f.idMain}')">
          
          <span class="rank-num">#${rankNum}</span>
          <span class="fighter-name">${escapeHtml(f.name)} ${champIcons}</span>
          <span class="fighter-record">${f.wins}-${f.losses}-${f.draws}</span>
          

          
        </div>`);
        
    });
  }
  
  /* Small trophy icons for platform champs */
  function getChampionIcons(f) {
    const icons = [];
    const champMap = {
      uflPC:'UFL PC', uflPS5:'UFL PS5', uflXbox:'UFL XBOX',
      rbcPC:'RBC PC', rbcPS5:'RBC PS5', rbcXbox:'RBC XBOX'
    };
    for (const [field,label] of Object.entries(champMap)) {
      if (champions[field] && f.ids.includes(champions[field])) {
        icons.push(`<i class="fas fa-trophy champ-icon" title="${label} CHAMPION"></i>`);
      }
    }
    return icons.join(' ');
  }
  
  /* Fights tab render */
  function renderFights() {
    const query = ($('fights-search')?.value || '').toLowerCase();
    const list = fights.slice().sort((a,b)=> new Date(b.date)-new Date(a.date));
    const container = $('fights-list');
    if (!container) return;
    container.innerHTML = '';
    list.forEach(f=>{
      const f1 = fighters.find(x=>x.id===f.fighter1)?.name || 'Unknown';
      const f2 = fighters.find(x=>x.id===f.fighter2)?.name || 'Unknown';
      const fightStr = `${f1} vs ${f2}`;
      if (query && !fightStr.toLowerCase().includes(query)) return;
      const winner = (f.winner==='0'||f.winner===0)?'Draw':(fighters.find(x=>x.id===f.winner)?.name || '');
      container.insertAdjacentHTML('beforeend',`
  <div class="fights-row">
    <div>${formatDateShort(f.date)}</div>
    <div>${escapeHtml(fightStr)}</div>
    <div>${escapeHtml(f.method || '')}</div>
    <div>${escapeHtml(winner)}</div>
  </div>
`);
    });
  }
  
 /* Players tab render ‚Äî with filters (KO, streak, activity, bonuses, champions) */
function renderPlayers() {
  const query = ($('players-search')?.value || '').toLowerCase();
  const filter = $('players-filter')?.value || 'none';
  const combinedList = buildCombinedMap();

  // Recalculate total points for each combined fighter
  combinedList.forEach(f => {
    f.points = calculateRankPoints(f.ids);
  });

  let list = combinedList.slice();

  // Apply FILTER logic
  switch (filter) {
    case 'mostKO':
      list.sort((a, b) => (b.koWins || 0) - (a.koWins || 0));
      break;

    case 'streak':
      list.sort((a, b) => countConsecutiveWins(b.ids) - countConsecutiveWins(a.ids));
      break;

    case 'active':
      // "Most Active" = most fights in the last 30 days
      list.sort((a, b) => recentFightCount(b.ids) - recentFightCount(a.ids));
      break;

    case 'bonus':
      // "Most Bonuses" = most POTN + FOTN
      list.sort((a, b) => totalBonuses(b.ids) - totalBonuses(a.ids));
      break;

    case 'champion':
      list = list.filter(f => isCurrentChampion(f.idMain));
      break;

    case 'formerChampion':
      list = list.filter(f => isFormerChampion(f.idMain));
      break;
  }

  // Filter by name query
  if (query) {
    list = list.filter(f => f.name.toLowerCase().includes(query));
  }

  // Sort by points descending by default
  if (filter === 'none') list.sort((a, b) => b.points - a.points);

  const container = $('players-list');
  if (!container) return;

  // Add column headers
  container.innerHTML = `
    <div class="player-header-row">
      <span class="player-header-left"></span>
      <span class="player-header-right"></span>
    </div>
  `;

  // Loop through players and render rows
  list.forEach(f => {
    const streak = computeStreakForCombined(f.ids);
    const streakClass = streak === 'hot' ? 'hot' : streak === 'cold' ? 'cold' : 'neutral';
    const streakSymbol = streak === 'hot' ? '‚ñ≤' : streak === 'cold' ? '‚ñº' : '‚Äì';

    container.insertAdjacentHTML(
      'beforeend',
      `
        <div class="player-row" onclick="openFighterModal('${f.idMain}')">
          <span class="players-column-left">
            <span class="streak ${streakClass}">${streakSymbol}</span>
            ${escapeHtml(f.name)}
          </span>
        </div>
      `
    );
  });
}

/* ===== Helper functions for filters ===== */

// Count fights in last 30 days
function recentFightCount(ids) {
  const now = new Date();
  return fights.filter(f =>
    (ids.includes(f.fighter1) || ids.includes(f.fighter2)) &&
    (now - new Date(f.date)) / (1000 * 60 * 60 * 24) <= 30
  ).length;
}

// Count total bonuses (POTN + FOTN)
function totalBonuses(ids) {
  return fights.filter(f =>
    (ids.includes(f.fighter1) || ids.includes(f.fighter2)) &&
    (f.bonus === 'POTN' || f.bonus === 'FOTN')
  ).length;
}


// ===== Alternative helper functions for single-fighter lookups =====
function totalRecentFights(fid) {
¬†¬†// Count fights in the last 30 days
¬†¬†const now = new Date();
¬†¬†return fights.filter(f => {
¬†¬†¬†¬†const d = new Date(f.date);
¬†¬†¬†¬†const days = (now - d) / (1000 * 60 * 60 * 24);
¬†¬†¬†¬†return days <= 30 && (f.fighter1 === fid || f.fighter2 === fid);
¬†¬†}).length;
}

function getBonusCount(fid) {
¬†¬†return fights.filter(f => 
¬†¬†¬†¬†(f.bonus === 'POTN' || f.bonus === 'FOTN') &&
¬†¬†¬†¬†(f.fighter1 === fid || f.fighter2 === fid)
¬†¬†).length;
}

function isCurrentChampion(fid) {
¬†¬†if (!champions) return false;
¬†¬†return Object.values(champions).includes(fid);
}

function isFormerChampion(fid) {
  return (formerChampions || []).includes(fid);
}
  
  /* Fighter modal (clickable name) with opponents list and badges ‚Äî SAFE VERSION */
function openFighterModal(id) {
  const modal = $('fighter-modal');
  const content = $('fighter-modal-content');

// Enable scrollable player card for overflow content
content.style.maxHeight = '80vh'; // limits height to 80% of screen
content.style.overflowY = 'auto';
content.style.scrollBehavior = 'smooth';


  // Ensure data exists
  if (!fighters || !Array.isArray(fighters) || fighters.length === 0) {
    alert('Fighter data not loaded yet.');
    return;
  }
  if (!fights || !Array.isArray(fights)) fights = [];

  // Find fighter by ID
  const f = fighters.find(x => x.id === id);
  if (!f) { alert('Fighter not found'); return; }

  // Find combined entry (across platforms)
  const combinedList = buildCombinedMap();
  const combinedEntry = combinedList.find(c => c.ids.includes(id));

  // Gather totals (fallback to fighter record if combined unavailable)
  const totalWins    = combinedEntry ? combinedEntry.wins    : parseInt(f.wins    || 0);
  const totalLosses  = combinedEntry ? combinedEntry.losses  : parseInt(f.losses  || 0);
  const totalDraws   = combinedEntry ? combinedEntry.draws   : parseInt(f.draws   || 0);
  const totalKOs     = combinedEntry ? combinedEntry.koWins  : parseInt(f.koWins  || 0);
  const allIDs       = combinedEntry ? combinedEntry.ids     : [f.id];

  // Compute badges using combined IDs
  const badges = computeBadgesForCombined(allIDs);

  // Build fights list safely
  let fightsList = '';
  try {
    fightsList = fights
      .filter(ft => allIDs.includes(ft.fighter1) || allIDs.includes(ft.fighter2))
      .sort((a,b) => new Date(b.date) - new Date(a.date))
      .map(ft => {
        const isDraw = (ft.winner === '0' || ft.winner === 0);
        const isWin  = allIDs.includes(ft.winner);
        const oppId  = allIDs.includes(ft.fighter1) ? ft.fighter2 : ft.fighter1;
        const oppName = fighters.find(x => x.id === oppId)?.name || 'Unknown';
        const result = isDraw ? 'Draw' : isWin ? 'Win' : 'Loss';
        return `<div class="fight-history-row">${formatDateShort(ft.date)} ‚Äî ${result} vs ${escapeHtml(oppName)} <span class="small-muted">(${escapeHtml(ft.method||'')})</span></div>`;
      })
      .join('');
  } catch (e) {
    console.error('Fight list render error:', e);
    fightsList = '<p>Unable to load fight history.</p>';
  }

  // Render modal content
  content.innerHTML = `

  
  
    <div class="fighter-modal-header">
    <div style="display:flex;justify-content:space-between;align-items:center;">

      
      <h2 style="font-size: 28px; font-weight: 700; color: var(--gold); margin-bottom: 4px;">
  ${escapeHtml(f.name)}
</h2>

  
  <button onclick="closeFighterModal()" style="background:none;border:0;color:#fff;font-size:18px;cursor:pointer;">‚úñ</button>
</div>

      <div class="fighter-badges">
        ${badges.map(b => `<span class="badge" title="${b.desc}">${b.icon}</span>`).join('')}
      </div>
    </div>
    <div class="fighter-modal-body">
    <p><strong>KO Wins:</strong> ${totalKOs}</p>

<!-- RANKING BREAKDOWN SECTION -->
<div class="ranking-breakdown-section" style="margin:12px 0;padding:10px;border:1px solid rgba(255,215,0,0.25);border-radius:8px;background:rgba(0,0,0,0.3);">
  <h3 style="color:var(--gold);margin-bottom:6px;">Ranking Breakdown</h3>
  <div id="ranking-breakdown-content" style="font-size:14px;color:#ccc;">
    Loading...
  </div>
</div>

<div class="fight-history">
        <h3>Past Fights</h3>
        ${fightsList || '<p>No fights yet.</p>'}
      </div>
    </div>`;
    // --- Live Ranking Breakdown injection ---
try {
  if (typeof calculateRankPoints === 'function' && allIDs?.length) {
    const breakdown = calculateRankPoints(allIDs, true);
    const bdEl = document.getElementById('ranking-breakdown-content');
    if (bdEl && breakdown) {
      bdEl.innerHTML = `
        <div><strong>Base Points:</strong> ${breakdown.base.toFixed(1)}</div>
        <div><strong>Finish Bonus:</strong> ${breakdown.finish.toFixed(1)}</div>
        <div><strong>Opponent Quality:</strong> ${breakdown.opponent.toFixed(1)}</div>
        <div><strong>Recency Bonus:</strong> ${breakdown.recency.toFixed(1)}</div>
        <div><strong>Streak Bonus:</strong> ${breakdown.streak.toFixed(1)}</div>
        <div><strong>Contender Bonus:</strong> ${breakdown.contender.toFixed(1)}</div>
        <div><strong>Modifiers:</strong> ${breakdown.modifiers.toFixed(1)}</div>
        <hr style="margin:6px 0;border-color:rgba(255,215,0,0.25);">
        <div><strong>Total:</strong> ${breakdown.total.toFixed(1)}</div>
      `;
    }
  }
} catch (e) {
  console.warn('Ranking Breakdown failed for', f.name, e);
  const bdEl = document.getElementById('ranking-breakdown-content');
  if (bdEl) bdEl.innerHTML = `<div style="color:#999;">No ranking data available.</div>`;
}


    // ‚ú® Gold border & pop-in animation for the player card
content.style.border = '1px solid gold';
content.style.boxShadow = '0 0 8px rgba(255, 215, 0, 0.4)';
content.style.borderRadius = '10px';
content.style.background = 'rgba(0, 0, 0, 0.92)';
content.style.transition = 'transform 0.25s ease-out, opacity 0.25s ease-out';
content.style.transform = 'scale(0.9)';
content.style.opacity = '0';
setTimeout(() => {
  content.style.transform = 'scale(1)';
  content.style.opacity = '1';
}, 10);

  modal.classList.remove('hidden');
}

  function closeFighterModal(){ $('fighter-modal').classList.add('hidden'); }
  
  /* Simple tab switcher (ensures one visible at all times) */
  function switchTab(tab) {
    const tabs = ['world','rbc','abc','caf','players','fights','admin'];
    tabs.forEach(t=>{
      const el = document.getElementById(t+'-tab');
      const btn = document.getElementById('btn-'+t);
      if(el) el.classList.toggle('hidden', t!==tab);
      if(btn) btn.classList.toggle('tab-active', t===tab);
    });
    renderAll();
 // üîì Auto-unlock admin dashboard when switching to Admin tab
 if (tab === 'admin') {
    const loginSection = document.getElementById('admin-login');
    const dashboard = document.getElementById('admin-dashboard');
    if (loginSection && dashboard) {
      loginSection.classList.add('hidden');
      dashboard.classList.remove('hidden');
    }
  }


  }
  document.addEventListener('DOMContentLoaded',()=>{ switchTab('world'); });
  </script>
  
  <style>
  /* crown & floating style refinements */
  .champion-card{background:rgba(0,0,0,0.25);border:1px solid rgba(255,215,0,0.1);border-radius:16px;padding:18px;text-align:center;position:relative;box-shadow:0 4px 20px rgba(0,0,0,0.4);}
  .floating-card{animation:floatCard 6s ease-in-out infinite;}
  @keyframes floatCard{0%,100%{transform:translateY(0)}50%{transform:translateY(-6px)}}
  .champion-crown{color:gold;font-size:34px;text-shadow:0 0 12px gold,0 0 20px rgba(255,215,0,0.6);}
  .champion-title{font-size:14px;letter-spacing:1px;color:#ffd700;margin-top:4px;}
  .champion-name{font-size:22px;font-weight:700;margin:6px 0;color:#fff;}
  .champion-name.clickable:hover{color:#ffd700;cursor:pointer;}
  .champion-name.vacant{color:#9ca3af;font-style:italic;}
  .champion-details{font-size:13px;opacity:0.9;}
  .champion-defenses{color:#4ade80;font-weight:600;}
  .champion-last-defense{font-size:13px;color:#9ca3af;margin-top:4px;}
  .badge{color:#facc15;font-size:16px;margin-right:6px;}
  .fight-history-row{margin:4px 0;font-size:14px;}
  .rank-num{width:36px;text-align:center;color:#9ca3af;font-weight:700;}
  /* crown & floating style refinements */
.champion-card {
  background: rgba(0,0,0,0.25);
  ...
}
.rank-num{width:36px;text-align:center;color:#9ca3af;font-weight:700;}

/* ‚úÖ ADD THIS NEW SECTION BELOW */
.player-header-row {
  display: flex;
  justify-content: space-between;
  padding: 8px 12px;
  font-weight: 700;
  color: #ffd700;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  margin-bottom: 4px;
}
.player-header-left, .player-header-right {
  flex: 1;
}
.player-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  border-bottom: 1px solid rgba(255,255,255,0.05);
}
.players-column-left {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 500;
  color: #fff;
}
.players-column-right {
  width: 70px;
  text-align: right;
  color: #9ca3af;
  font-weight: 600;
}

/* keep whatever comes next */
</style>
<!-- END Part 5 of 6 -->

  </style>
  <!-- END Part 5 of 6 -->
<!-- START Part 6 of 6 -->
<script>
  /* =========================================
     üõ†Ô∏è  ADMIN: add/edit/delete fights & fighters,
           champion assignment, save, and init
     ========================================= */
  
  /* Populate fighter selects used when adding or editing fights */
  function populateEditFightSelects() {
    const fList = fighters.slice().sort((a,b)=> (a.name||'').localeCompare(b.name||''));
    const addF1 = $('add-fight-f1'), addF2 = $('add-fight-f2'), addWinner = $('add-fight-winner');
    const editF1 = $('edit-fight-f1'), editF2 = $('edit-fight-f2'), editWinner = $('edit-fight-winner');
  
    if(addF1) { addF1.innerHTML = '<option value="">-- select fighter --</option>'; }
    if(addF2) { addF2.innerHTML = '<option value="">-- select fighter --</option>'; }
    if(addWinner) { addWinner.innerHTML = '<option value="0">Draw</option>'; }
  
    if(editF1) { editF1.innerHTML = '<option value="">-- select fighter --</option>'; }
    if(editF2) { editF2.innerHTML = '<option value="">-- select fighter --</option>'; }
    if(editWinner) { editWinner.innerHTML = '<option value="0">Draw</option>'; }
  
    fList.forEach(f=>{
      const optHtml = `<option value="${f.id}">${escapeHtml(f.name)} (${escapeHtml(f.platform||'‚Äî')})</option>`;
      if(addF1) addF1.insertAdjacentHTML('beforeend', optHtml);
      if(addF2) addF2.insertAdjacentHTML('beforeend', optHtml);
      if(editF1) editF1.insertAdjacentHTML('beforeend', optHtml);
      if(editF2) editF2.insertAdjacentHTML('beforeend', optHtml);
  
      if(addWinner) addWinner.insertAdjacentHTML('beforeend', `<option value="${f.id}">${escapeHtml(f.name)}</option>`);
      if(editWinner) editWinner.insertAdjacentHTML('beforeend', `<option value="${f.id}">${escapeHtml(f.name)}</option>`);
    });
  }
  
  /* Populate admin fights dropdown (input order = firestore order assumed) */
  function populateAdminFightsDropdown(){
    const sel = $('admin-fights-dropdown');
    if(!sel) return;
    sel.innerHTML = '';
    // list by creation order if stored, else reverse date order -> we'll use current fights array reverse to approximate input order
    fights.slice().reverse().forEach(f=>{
      const n1 = fighters.find(x=>x.id===f.fighter1)?.name || 'Unknown';
      const n2 = fighters.find(x=>x.id===f.fighter2)?.name || 'Unknown';
      const opt = document.createElement('option');
      opt.value = f.id;
      opt.text = `${formatDateShort(f.date)} ‚Äî ${n1} vs ${n2}`;
      sel.appendChild(opt);
    });
  }
  
  /* Populate admin fights visual list */
  function populateAdminFightsList(){
    const container = $('admin-fights-list');
    if(!container) return;
    container.innerHTML = '';
    fights.slice().reverse().forEach(f=>{
      const n1 = fighters.find(x=>x.id===f.fighter1)?.name || 'Unknown';
      const n2 = fighters.find(x=>x.id===f.fighter2)?.name || 'Unknown';
      const d = document.createElement('div');
      d.style.padding = '8px';
      d.style.borderBottom = '1px solid rgba(255,255,255,0.03)';
      d.innerHTML = `<strong>${formatDateShort(f.date)}</strong> ‚Äî ${escapeHtml(n1)} vs ${escapeHtml(n2)} <span class="small-muted">[${escapeHtml(f.platform||'')}]</span>`;
      container.appendChild(d);
    });
  }
  
  /* Populate champion title selects in admin UI */
  function populateChampionTitleSelects(){
    const container = $('champion-titles-container');
    if(!container) return;
    container.innerHTML = '';
    const opts = fighters.slice().map(f=>({ id:f.id, label:`${f.name} (${f.platform||'‚Äî'})` })).sort((a,b)=>a.label.localeCompare(b.label));
  
    // We'll create two-column grid of selects for TITLES array
    TITLES.forEach(title=>{
      const field = mapTitleToField(title);
      const wrapper = document.createElement('div');
      wrapper.style.padding = '8px';
      wrapper.style.borderRadius = '8px';
      wrapper.style.background = 'transparent';
      const label = document.createElement('div');
      label.style.fontWeight = '700';
      label.style.marginBottom = '6px';
      label.textContent = title;
      const sel = document.createElement('select');
      sel.id = `champ-select-${field}`;
      sel.style.width = '100%';
      sel.style.padding = '8px';
      const empty = document.createElement('option'); empty.value = ''; empty.text = '-- Unassigned --';
      sel.appendChild(empty);
      opts.forEach(o=>{
        const opt = document.createElement('option'); opt.value = o.id; opt.text = o.label;
        sel.appendChild(opt);
      });
      // set current value if exists
      if(champions && champions[field]) sel.value = champions[field];
  
      wrapper.appendChild(label);
      wrapper.appendChild(sel);
  
      // For UFL world & CAF add defenses input and last defense display
      if(field === 'uflWorld' || field === 'uflCAF'){
        const defLabel = document.createElement('div'); defLabel.style.marginTop='8px'; defLabel.style.fontSize='13px'; defLabel.textContent = 'Title Defenses (editable)';
        const defInput = document.createElement('input'); defInput.type='number'; defInput.min='0'; defInput.id = `champ-${field}-def`; defInput.style.width='120px'; defInput.style.marginTop='6px';
        defInput.value = field === 'uflWorld' ? (champions.uflWorldDefenses||0) : (champions.uflCAFDefenses||0);
        const lastDiv = document.createElement('div'); lastDiv.style.fontSize='12px'; lastDiv.style.marginTop='6px';
        const lastDate = field === 'uflWorld' ? formatDateShort(champions.uflWorldLastDefense) : formatDateShort(champions.uflCAFLastDefense);
        lastDiv.innerHTML = `Last Defense: ${lastDate || 'N/A'}`;
        wrapper.appendChild(defLabel); wrapper.appendChild(defInput); wrapper.appendChild(lastDiv);
      }
  
// Vacate button for convenience
const vac = document.createElement('button');
vac.className = 'btn';
vac.style.marginTop = '8px';
vac.textContent = 'Vacate';
vac.onclick = async () => {
  if (!confirm(`Vacate ${title}?`)) return;

  const updates = {};
  updates[field] = null;
  if (field === 'uflWorld') {
    updates.uflWorldDefenses = 0;
    updates.uflWorldLastDefense = '';
  }
  if (field === 'uflCAF') {
    updates.uflCAFDefenses = 0;
    updates.uflCAFLastDefense = '';
  }

  try {
    await db.collection('settings').doc('champions').set(updates, { merge: true });
    alert('Vacated');

    // ‚úÖ Allow Firestore to update locally, then re-run logic
    setTimeout(() => {
      saveChampionAssignments(); // Ensures former champ tracking + UI refresh
    }, 500);
  } catch (e) {
    console.error(e);
    alert('Failed to vacate');
  }
};
wrapper.appendChild(vac);


container.appendChild(wrapper);

  
    // If admin is logged in, inject YouTube admin controls near titles container
    injectAdminSocialControls();
  }
  
/* Save champion assignments from admin form ‚Äî now tracks and persists former champions */
async function saveChampionAssignments() {
  const payload = {};
  const previousChampions = { ...champions }; // snapshot current champs before overwrite

  TITLES.forEach(title => {
    const field = mapTitleToField(title);
    const sel = $(`champ-select-${field}`);
    payload[field] = (sel && sel.value) ? sel.value : null;

    // Handle defense counts
    if (field === 'uflWorld') {
      const def = parseInt($('champ-uflWorld-def')?.value || 0, 10) || 0;
      payload.uflWorldDefenses = def;
    }
    if (field === 'uflCAF') {
      const def = parseInt($('champ-uflCAF-def')?.value || 0, 10) || 0;
      payload.uflCAFDefenses = def;
    }
  });

  try {
    // ‚úÖ Save the new assignments
    await db.collection('settings').doc('champions').set(payload, { merge: true });

    // ‚úÖ Refresh local champion data
    const snap = await db.collection('settings').doc('champions').get();
    if (snap.exists) champions = snap.data();

    // üß© Compare old champs vs new champs
    const formerIds = [];
    Object.keys(payload).forEach(key => {
      const oldChamp = previousChampions?.[key];
      const newChamp = payload?.[key];
      if (oldChamp && oldChamp !== newChamp) {
        formerIds.push(oldChamp);
      }
    });

    // üè∑Ô∏è Mark any displaced champions as "formerChampion: true" and persist
    if (formerIds.length > 0) {
      const batch = db.batch();

      // Mark on fighter documents
      formerIds.forEach(fid => {
        const ref = db.collection('fighters').doc(fid);
        batch.set(ref, { formerChampion: true }, { merge: true });
      });

      // Persist global list of former champions
      const formersRef = db.collection('settings').doc('formerChampions');
      await formersRef.set({ list: formerIds }, { merge: true });

      await batch.commit();
      console.log('Former champions marked and persisted:', formerIds);
    }

    // ‚úÖ REMOVE "formerChampion" flag if they are CURRENT champions again
    const currentChampIds = Object.values(payload).filter(Boolean);
    if (currentChampIds.length > 0) {
      const batch2 = db.batch();
      currentChampIds.forEach(fid => {
        const ref = db.collection('fighters').doc(fid);
        batch2.set(ref, { formerChampion: false }, { merge: true });
      });
      await batch2.commit();
      console.log('Updated current champs to clear formerChampion flag:', currentChampIds);
    }

    // ‚úÖ Re-render all displays with updated data
    renderAll();

    alert('Champion assignments saved and former champions updated.');
  } catch (e) {
    console.error('Failed to save champion assignments:', e);
    alert('Failed to save champions');
  }
}


  
  /* Clear all champion assignments */
  async function resetChampionAssignments(){
    if(!confirm('Clear all champion assignments?')) return;
    const payload = {
      uflWorld:null, uflWorldDefenses:0, uflWorldLastDefense:'',
      uflCAF:null, uflCAFDefenses:0, uflCAFLastDefense:'',
      uflPC:null, uflPS5:null, uflXbox:null,
      rbcPC:null, rbcPS5:null, rbcXbox:null
    };
    try{ await db.collection('settings').doc('champions').set(payload, { merge:true }); alert('Cleared'); }catch(e){console.error(e); alert('Failed');}
  }
  
  /* Admin: Add Fighter */
  function adminAddFighter(){
    const name = ($('add-fighter-name')?.value || '').trim();
    const platform = ($('add-fighter-platform')?.value || '').trim();
    if(!name) return alert('Enter a name');
    const payload = { name, platform, wins:0, losses:0, draws:0, koWins:0, retired:false, isCAF:false };
    db.collection('fighters').add(payload).then(()=> {
      $('add-fighter-name').value = '';
      populateEditFightSelects();
      populateAdminFighters();
      alert('Fighter added.');
    }).catch(e=>{ console.error(e); alert('Failed to add fighter'); });
  }
  
  /* Recompute ALL fighter stats from fights (safe canonical source of truth) */
  async function recomputeAllFighterStats(){
    const stats = {};
    fighters.forEach(f => stats[f.id] = { wins:0, losses:0, draws:0, koWins:0 });
  
    fights.forEach(ft => {
      const f1 = ft.fighter1, f2 = ft.fighter2;
      if(!f1 || !f2) return;
      const winner = (ft.winner === '0' || ft.winner === 0) ? 'DRAW' : ft.winner;
      if(winner === 'DRAW'){
        if(stats[f1]) stats[f1].draws++;
        if(stats[f2]) stats[f2].draws++;
      } else {
        if(stats[winner]) stats[winner].wins++;
        const loser = (winner === f1) ? f2 : f1;
        if(stats[loser]) stats[loser].losses++;
        if((ft.method||'').toLowerCase().includes('ko') && stats[winner]) stats[winner].koWins++;
      }
    });
  
    // batch commit updates
    const batch = db.batch();
    Object.keys(stats).forEach(fid=>{
      const ref = db.collection('fighters').doc(fid);
      batch.set(ref, {
        wins: stats[fid].wins,
        losses: stats[fid].losses,
        draws: stats[fid].draws,
        koWins: stats[fid].koWins
      }, { merge:true });
    });
    try{
      await batch.commit();
      console.log('Recomputed fighter stats from fights.');
    }catch(e){ console.error('recompute stats error', e); }
  }
  
  /* Admin: Add Fight */
async function adminAddFight() {
  const platform = $('add-fight-platform')?.value || '';
  const f1 = $('add-fight-f1')?.value;
  const f2 = $('add-fight-f2')?.value;
  const method = $('add-fight-method')?.value || '';
  const winner = $('add-fight-winner')?.value || '0';
  const date = $('add-fight-date')?.value;
  const caf = ($('add-fight-caf')?.value === 'true');
  const bonus = $('add-fight-bonus')?.value || 'none';
  const title = $('add-fight-title')?.value || 'none';
  const region = $('add-fight-region')?.value || 'NA'; // üÜï this line moved here

  if (!f1 || !f2) return alert('Select both fighters');
  if (f1 === f2) return alert('Fighter cannot fight themselves');
  if (!date) return alert('Select a date');

  // ‚úÖ region is now properly part of the Firestore document
  const payload = {
    fighter1: f1,
    fighter2: f2,
    fighter1Name: fighters.find(x => x.id === f1)?.name || '',
    fighter2Name: fighters.find(x => x.id === f2)?.name || '',
    platform,
    method,
    winner: winner || '0',
    date,
    caf,
    region, 
    title,
    bonus, // üÜï Added here
  };

  try {
    await db.collection('fights').add(payload);
    await recomputeAllFighterStats();
    populateAdminFightsDropdown();
    populateAdminFightsList();
    renderAll();
    alert('Fight added.');
  } catch (e) {
    console.error('Failed to add fight:', e);
    alert('Failed to add fight');
  }
}


  
  /* Admin: Edit selected fight - open modal and populate */
  
  function adminEditSelectedFight() {
  const id = $('admin-fights-dropdown')?.value;
  if (!id) return alert('Select a fight to edit.');
  const fight = fights.find(f => f.id === id);
  if (!fight) return alert('Fight not found.');

  // Show modal
  $('edit-fight-modal').classList.remove('hidden');

  // Populate existing fields
  $('edit-fight-f1').value = fight.fighter1 || '';
  $('edit-fight-f2').value = fight.fighter2 || '';
  $('edit-fight-platform').value = fight.platform || 'PC';
  $('edit-fight-method').value = fight.method || 'KO/TKO';
  $('edit-fight-winner').value = fight.winner || '0';
  $('edit-fight-date').value = fight.date ? fight.date.split('T')[0] : '';
  $('edit-fight-caf').value = fight.caf ? 'true' : 'false';

  // üÜï NEW: populate region field
  $('edit-fight-region').value = fight.region || 'NA';
}


    $('edit-fight-f1').value = fight.fighter1 || '';
    $('edit-fight-f2').value = fight.fighter2 || '';
    $('edit-fight-platform').value = fight.platform || '';
    $('edit-fight-method').value = fight.method || '';
    $('edit-fight-winner').value = fight.winner || '0';
    $('edit-fight-date').value = fight.date ? fight.date.split('T')[0] : fight.date;
    $('edit-fight-caf').value = fight.caf ? 'true' : 'false';
    $('edit-fight-region').value = fight.region || 'NA'; // üÜï populate region
    $('edit-fight-modal').dataset.editing = fid;
    $('edit-fight-modal').classList.remove('hidden');
  }
  
  /* Close edit fight modal */
  function closeEditFightModal(){
    const modal = $('edit-fight-modal');
    if(!modal) return;
    modal.classList.add('hidden');
    delete modal.dataset.editing;
  }
  
  /* Save edited fight */
  async function saveEditedFight(){
    const fid = $('edit-fight-modal')?.dataset?.editing;
    if(!fid) return alert('No fight selected');
    const f1 = $('edit-fight-f1').value;
    const f2 = $('edit-fight-f2').value;
    const platform = $('edit-fight-platform').value;
    const method = $('edit-fight-method').value;
    const winner = $('edit-fight-winner').value || '0';
    const date = $('edit-fight-date').value;
    const caf = ($('edit-fight-caf').value === 'true');
    
  
    if(!f1 || !f2) return alert('Select both fighters');
    if(f1 === f2) return alert('Fighters must be different');
    if(!date) return alert('Select date');
  
    try{
      await db.collection('fights').doc(fid).set({
  fighter1: f1,
  fighter2: f2,
  fighter1Name: fighters.find(x => x.id === f1)?.name || '',
  fighter2Name: fighters.find(x => x.id === f2)?.name || '',
  platform,
  method,
  winner: winner || '0',
  date,
  caf,
  region: $('edit-fight-region').value || 'NA' // single trailing property ‚Äî no comma needed here
}, { merge: true });

      await recomputeAllFighterStats();
      closeEditFightModal();
      populateAdminFightsDropdown();
      populateAdminFightsList();
      renderAll();
      alert('Saved.');
    }catch(e){ console.error(e); alert('Failed to save fight'); }
  }
  
  /* Confirm delete fight within edit modal */
  function confirmDeleteFight(){
    if(!confirm('Delete this fight?')) return;
    const fid = $('edit-fight-modal')?.dataset?.editing;
    if(!fid) return alert('No fight selected');
    adminDeleteFight(fid);
  }
  
  /* Admin: Delete selected fight from dropdown */
  async function adminDeleteSelectedFight(){
    const sel = $('admin-fights-dropdown'); if(!sel || !sel.value) return alert('Select a fight');
    const id = sel.value;
    if(!confirm('Delete selected fight?')) return;
    await adminDeleteFight(id);
  }
  
  /* Delete fight helper */
  async function adminDeleteFight(id){
    try{
      
// üóëÔ∏è Delete fight
$('delete-fight-btn').addEventListener('click', async () => {
  const selectedFightId = $('admin-fights-dropdown').value;
  if (!selectedFightId) return alert('Select a fight first!');
  if (!confirm('Are you sure you want to delete this fight?')) return;

  // Delete the fight from Firestore
  await deleteDoc(doc(db, "fights", selectedFightId));

  // üîÅ Reload fights and recalculate records/points
  await loadFightsFromFirestore();
  await recomputeAllFighterStats(); // <-- THIS FIXES RECORDS NOT UPDATING

  // Rebuild UI
  populateAdminFightsDropdown();
  populateAdminFightsList();
  renderAll();

  alert('Fight deleted and stats updated.');
});

      closeEditFightModal();
      alert('Deleted.');
    }catch(e){ console.error(e); alert('Failed to delete'); }
  }
  
  /* Admin: delete fighter */
  function deleteFighter(id){
    if(!confirm('Delete fighter? This removes them from fighters collection (fights remain).')) return;
    db.collection('fighters').doc(id).delete().then(()=>{ alert('Deleted fighter.'); }).catch(e=>{ console.error(e); alert('Failed'); });
  }
  
  /* Toggle retire/unretire */
  function toggleRetire(id){
    const f = fighters.find(x=>x.id===id);
    if(!f) return;
    const newVal = !f.retired;
    if(!confirm(`${newVal ? 'Retire' : 'Unretire'} ${f.name}?`)) return;
    db.collection('fighters').doc(id).set({ retired:newVal }, { merge:true }).then(()=>{ alert('Updated.'); }).catch(e=>{ console.error(e); alert('Failed'); });
  }
  
  /* Edit fighter inline (simple prompt UI) */
  function openEditFighter(id){
    const f = fighters.find(x=>x.id===id);
    if(!f) return;
    const newName = prompt('Edit fighter name:', f.name);
    if(newName === null) return;
    const newPlatform = prompt('Edit platform (PC / PS5 / XBOX):', f.platform || 'PC');
    if(newPlatform === null) return;
    db.collection('fighters').doc(id).set({ name:newName.trim(), platform:newPlatform.trim() }, { merge:true }).then(()=>{ alert('Saved'); }).catch(e=>{ console.error(e); alert('Failed'); });
  }
  
  /* Map title string to settings field */
  function mapTitleToField(title){
    switch(title){
      case 'UFL World Champion': return 'uflWorld';
      case 'UFL CAF Champion': return 'uflCAF';
      case 'UFL PC Champion': return 'uflPC';
      case 'UFL PS5 Champion': return 'uflPS5';
      case 'UFL Xbox Champion': return 'uflXbox';
      case 'RBC PC Champion': return 'rbcPC';
      case 'RBC PS5 Champion': return 'rbcPS5';
      case 'RBC Xbox Champion': return 'rbcXbox';
      default: return title.replace(/\s+/g,'').toLowerCase();
    }
  }
  
  /* Inject admin social controls (YouTube save UI) */
  function injectAdminSocialControls(){
    if(!sessionStorage.getItem('isAdmin')) return;
    if($('admin-youtube-control')) return; // already injected
    const container = $('champion-titles-container');
    if(!container) return;
    const div = document.createElement('div');
    div.id = 'admin-youtube-control';
    div.style.gridColumn = 'span 2';
    div.className = 'frosted';
    div.innerHTML = `<div style="font-weight:700;margin-bottom:6px;">Social / YouTube</div>
      <div class="small-muted">Enter a playlist ID to enable embedding on Social tab</div>
      <div style="margin-top:8px;"><input id="admin-youtube-playlist" placeholder="YouTube playlist ID" style="width:60%;padding:8px;" /><button class="btn btn-primary" style="margin-left:8px;" onclick="saveYoutubePlaylist()">Save</button></div>`;
    container.parentElement.appendChild(div);
    setTimeout(()=>{ $('admin-youtube-playlist').value = champions.youtubePlaylist || ''; }, 120);
  }
  
  /* Save YouTube playlist ID into champions settings doc */
  function saveYoutubePlaylist(){
    const val = $('admin-youtube-playlist')?.value.trim() || '';
    db.collection('settings').doc('champions').set({ youtubePlaylist: val }, { merge:true }).then(()=>{ alert('Saved'); }).catch(e=>{ console.error(e); alert('Failed'); });
  }
  
  /* Populate admin fighters table */
  function populateAdminFighters(){
    const tbody = $('admin-fighters-list');
    if(!tbody) return;
    tbody.innerHTML = '';
    fighters.slice().forEach(f=>{
      const combined = buildCombinedMap().find(c=> c.ids.includes(f.id));
      const points = combined ? (combined.points || 0) : 0;
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${escapeHtml(f.name)} ${f.retired ? '<span style="color:#f87171;font-size:12px;margin-left:6px;">[Retired]</span>' : ''}</td>
        <td>${escapeHtml(f.platform||'‚Äî')}</td>
        <td>${(f.wins||0)}-${(f.losses||0)}-${(f.draws||0)}</td>
        <td>${Number(points).toFixed(1)}</td>
        <td>
          <button class="btn" onclick="openEditFighter('${f.id}')"><i class="fas fa-edit"></i></button>
          <button class="btn" onclick="toggleRetire('${f.id}')">${f.retired ? '<i class="fas fa-undo"></i>' : '<i class="fas fa-user-slash"></i>'}</button>
          <button class="btn btn-danger" onclick="deleteFighter('${f.id}')"><i class="fas fa-trash"></i></button>
        </td>
      `;
      tbody.appendChild(tr);
    });
  }
  
  /* ADMIN: Login / Logout (simple check against stored ADMIN_PW or fallback test password) */
  function attemptAdminLogin(){
    const input = $('admin-pass')?.value || '';
    $('admin-login-error').style.display = 'none';
    const ok = (window.ADMIN_PW && input === window.ADMIN_PW) || (!window.ADMIN_PW && input === 'ufltest123');
    if(ok){
      sessionStorage.setItem('isAdmin','true');
      $('admin-login').classList.add('hidden');
      $('admin-dashboard').classList.remove('hidden');
      populateChampionTitleSelects();
      populateAdminFighters();
      populateAdminFightsDropdown();
      populateAdminFightsList();
      injectAdminSocialControls();
      alert('Admin unlocked.');
    } else {
      $('admin-login-error').textContent = 'Invalid password';
      $('admin-login-error').style.display = 'block';
    }
  }
  function logoutAdmin(){
    sessionStorage.removeItem('isAdmin');
    $('admin-dashboard').classList.add('hidden');
    $('admin-login').classList.remove('hidden');
    switchTab('world');
  }
  
  /* Utility to repopulate admin UI parts */
  function repopulateAllAdminViews(){
    populateEditFightSelects();
    populateAdminFightsDropdown();
    populateAdminFightsList();
    populateChampionTitleSelects();
    populateAdminFighters();
  }
  
  /* Initialize page (called at load) */
  function initPage(){
    populateEditFightSelects();
    populateAdminFightsDropdown();
    populateAdminFightsList();
    populateChampionTitleSelects();
    populateAdminFighters();
    renderAll();
    if(sessionStorage.getItem('isAdmin')){
      $('admin-login')?.classList.add('hidden');
      $('admin-dashboard')?.classList.remove('hidden');
      injectAdminSocialControls();
    }
  }
  
  /* Close modals when clicking backdrop */
  document.addEventListener('click', (e)=>{
    if(e.target.classList && e.target.classList.contains('modal-backdrop')){
      if(e.target.id === 'fighter-modal') closeFighterModal();
      if(e.target.id === 'edit-fight-modal') closeEditFightModal();
    }
  });
  
  /* Kick off initial setup after listeners have time to fill data */
  setTimeout(initPage, 600);

 /* üîì AUTO-UNLOCK ADMIN DASHBOARD ON PAGE LOAD (FOR TESTING) */
document.addEventListener('DOMContentLoaded', () => {
  const loginSection = document.getElementById('admin-login');
  const dashboard = document.getElementById('admin-dashboard');

  if (loginSection && dashboard) {
    loginSection.classList.add('hidden');
    dashboard.classList.remove('hidden');
    console.log('‚úÖ Admin panel auto-unlocked for testing');
  }
});


  </script>
  
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("admin-login").classList.add("hidden");
      document.getElementById("admin-dashboard").classList.remove("hidden");
    });
    </script>
    

  </body>
  </html>
  <!-- END Part 6 of 6 -->
        
