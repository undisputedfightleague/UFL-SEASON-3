<!-- START Part 1 of 6 -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>UFL SEASON 3</title>



<!-- Firebase (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>

<!-- Tailwind (for utility) and FontAwesome -->
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&family=Oxanium:wght@300;400;600;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>

<style>
:root{ --gold:#FFD700; --muted:#9ca3af; --card-bg: rgba(8,8,10,0.56); }
html,body{height:100%;margin:0;padding:0}
body{
  font-family:'Oxanium',sans-serif;
  background:
    radial-gradient(ellipse at center, rgba(255,215,140,0.03) 0%, rgba(0,0,0,0.5) 60%, rgba(0,0,0,0.75) 100%),
    linear-gradient(120deg,#070707 0%, #0f0f0f 40%, #070707 100%),
    linear-gradient(45deg, rgba(255,255,255,0.015) 0%, rgba(0,0,0,0.05) 50%, rgba(255,255,255,0.01) 100%);
  color:#fff; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  min-height:100vh; padding-bottom:48px;

    padding-top: 70px; /* leave space for sticky tab bar */

}

.container{ max-width:1100px; margin:18px auto; padding:0 16px; }
.frosted{ background:var(--card-bg); border:1px solid rgba(255,215,0,0.06); backdrop-filter: blur(7px); padding:14px; border-radius:12px; }
.header{ font-family:'Orbitron',sans-serif; font-size:28px; color:var(--gold); text-align:center; margin-bottom:6px; }
.submuted{ color:var(--muted); font-size:13px; text-align:center; margin-bottom:8px; }

.tabs{ display:flex; gap:8px; margin-bottom:12px; flex-wrap:wrap; justify-content:center; }
.tab-btn{ background:transparent; border:0; padding:8px 12px; cursor:pointer; color:#ddd; border-bottom:2px solid transparent; font-family:'Orbitron'; font-size:13px; text-transform:uppercase; letter-spacing:1px; }
.tab-active{ color:var(--gold); border-bottom-color:var(--gold); }

/* üì± Mobile tab bar fix */
.tabs {
  position: sticky;            /* stays visible when scrolling */
  top: 0;
  z-index: 999;                /* keeps it above content */
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: nowrap;           /* keep buttons on one line */
  overflow-x: auto;            /* allow horizontal scroll if needed */
  gap: 6px;
  padding: 8px 4px;
  background: rgba(0, 0, 0, 0.85);  /* dark semi-transparent bar */
  backdrop-filter: blur(6px);       /* subtle blur */
  border-bottom: 1px solid rgba(255, 215, 0, 0.2); /* gold divider */
}

/* hide scrollbar visually but keep touch scroll */
.tabs::-webkit-scrollbar {
  display: none;
}

.tab-btn {
  flex: 0 0 auto;              /* prevent shrinking */
  white-space: nowrap;         /* keep text on one line */
  font-size: 14px;
  padding: 8px 12px;
  border-radius: 10px;
}

/* mobile layout tweaks */
@media (max-width: 768px) {
  .tabs {
    justify-content: flex-start;  /* align to left on mobile */
    padding: 10px;
  }
}


.grid-main{ display:grid; grid-template-columns:320px 1fr; gap:18px; align-items:start; }
.champion-card{ border-radius:14px; padding:18px; border:1px solid rgba(255,215,0,0.16); background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12)); animation: floaty 6s ease-in-out infinite; position:relative; }
@keyframes floaty{0%{transform:translateY(0)}50%{transform:translateY(-6px)}100%{transform:translateY(0)}}
.champ-crown{ font-size:28px; color:var(--gold); display:block; text-align:center; margin-top:-6px; }
.champ-title{ font-size:12px; color:#e9d9a0; letter-spacing:1px; text-transform:uppercase; text-align:center; }
.champ-name{ font-family:'Orbitron'; font-size:22px; text-align:center; margin-top:6px; color:var(--gold); cursor:pointer; }
.champ-meta{ font-size:13px; text-align:center; color:#ddd; margin-top:6px; }

.rank-list{ display:flex; flex-direction:column; gap:8px; max-height:540px; overflow:auto; padding-right:6px; }
.rank-row{ display:flex; justify-content:space-between; align-items:center; padding:12px; border-radius:10px; background:rgba(0,0,0,0.18); }
.fighter-link{ color:inherit; text-decoration:none; cursor:pointer; font-weight:600; font-family:Orbitron; }
.small-muted{ color:var(--muted); font-size:12px; }
.icon-champ{ color:var(--gold); margin-left:6px; }

table{ width:100%; border-collapse:collapse; }
th,td{ padding:8px 6px; text-align:left; border-bottom:1px solid rgba(255,255,255,0.03); font-size:13px; }
.btn{ padding:8px 10px; border-radius:8px; cursor:pointer; border:0; }
.btn-primary{ background:#2563eb; color:#fff; }
.btn-danger{ background:#c0392b; color:#fff; }
.btn-yellow{ background:var(--gold); color:#000; }

.hidden{ display:none !important; }
.muted{ color:var(--muted); font-size:13px; }

.modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:60; }
.modal{ background:rgba(6,6,6,0.94); padding:16px; border-radius:10px; max-width:900px; width:100%; color:#fff; }

input,select{ padding:8px; border-radius:6px; background:rgba(0,0,0,0.36); color:#fff; border:1px solid rgba(255,255,255,0.04); }

.players-header,.fights-header{ display:flex; justify-content:space-between; align-items:center; padding:8px 12px; border-radius:8px; background:rgba(255,255,255,0.02); margin-bottom:6px; font-weight:700; font-family:Orbitron; }
.players-columns{ display:flex; justify-content:space-between; gap:6px; width:100%; }
.players-column-left{ width:70%; display:flex; align-items:center; gap:8px; }
.players-column-right{ width:30%; text-align:right; }

/* Fights layout: Date | Fight | Method | Winner */
.fights-columns {
  display: grid;
  grid-template-columns: 100px 1fr 120px 140px; /* narrower Date column */
  gap: 14px; /* wider gap between all columns */
  width: 100%;
  font-weight: 700;
  color: var(--gold);
  border-bottom: 1px solid rgba(255,255,255,0.1);
  padding-bottom: 6px;
  align-items: center;
}

.fights-row {
  display: grid;
  grid-template-columns: 100px 1fr 120px 140px;
  gap: 14px;
  align-items: center;
  width: 100%;
  padding: 8px 0;
  border-bottom: 1px solid rgba(255,255,255,0.05);
  font-size: 14px;
}

/* mobile adjustments */
@media (max-width: 900px) {
  .fights-columns,
  .fights-row {
    grid-template-columns: 70px 1fr 80px 100px;
    font-size: 13px;
    gap: 10px;
  }
}



.streak{ font-size:14px; margin-right:6px; }
.streak.hot{ color:#ffb86b; }
.streak.cold{ color:#7ad3ff; }
.streak.neutral{ color:#d1d5db; }

.breakdown{ border-top:1px solid rgba(255,215,0,0.08); margin-top:12px; padding-top:10px; color:var(--muted); font-size:13px; }
.breakdown strong{ color:var(--gold); }

.badge {
  margin-right: 8px;
  padding: 6px 8px;
  border-radius: 8px;
  background: rgba(255,255,255,0.02);
  border: 1px solid rgba(255,215,0,0.15);
  font-size: 14px;
  cursor: pointer; /* üëà changed from help ‚Üí pointer */
  transition: transform 0.15s ease, background 0.15s ease;
  display: inline-block;
  color: #facc15; /* gold tone for consistency */
}

.badge:hover {
  background: rgba(255,215,0,0.1);
  transform: scale(1.1); /* üëà subtle pop on hover */
}


.rank-num{width:40px;text-align:center;color:#9ca3af;font-weight:700;margin-right:8px;}
.fighter-row {
  display: grid;
  grid-template-columns: 40px 1fr 100px 80px; /* Rank | Name | Record | Points */
  align-items: center;
  gap: 12px;
  padding: 10px;
  border-radius: 8px;
  background: rgba(0,0,0,0.14);
}

.fighter-name {
  text-align: left;
}

.fighter-record {
  text-align: center;
  width: 100%;
}

.fighter-points {
  text-align: right;
  width: 80px;
}

@media (max-width:900px){
  .grid-main{ grid-template-columns:1fr; }
  .champ-card{ margin:0 auto; max-width:420px; }
  .tabs{ justify-content:flex-start; overflow:auto; padding-left:8px; }
  .fights-columns,.fights-row{ grid-template-columns:1fr 120px 100px 100px; }
}



/* Hide inactive tab content */
.tab-content.hidden { display: none; }

/* üè† HOME TAB STYLES */
#home-tab {
  text-align: center;
  padding: 40px 20px;
}

#home-tab h1 {
  font-size: 2rem;
  color: var(--gold);
  margin-bottom: 10px;
}

#home-tab {
  padding: 40px 20px;
  max-width: 800px;
  margin: 0 auto;
}

#home-tab h1 {
  text-align: center;  /* keep only the main title centered */
}

#home-tab h2,
#home-tab p,
#home-tab ul {
  text-align: left;    /* align all other text to the left */
}


#home-tab p {
  font-size: 1.1rem;
  color: #ccc;
  margin: 6px 0;
}

/* üß© Make player cards act like modals */
.player-card-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100vh;
  overflow-y: auto;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(6px);
  z-index: 2000;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding: 60px 10px 20px 10px;
}

/* üö´ Lock background scroll when modal is open */
body.modal-open {
  overflow: hidden !important;
  position: fixed;
  width: 100%;
}

/* Ensure modal always covers everything */
#fighter-modal {
  position: fixed;
  inset: 0;
  z-index: 5000; /* above .tabs (z=999) */
  overflow-y: auto;
}

/* üì± Prevent horizontal scroll on mobile */
html, body {
  overflow-x: hidden;
  width: 100%;
  max-width: 100%;
}

/* Ensure all major containers respect viewport width */
.container,
#world-tab,
#players-tab,
#fights-tab,
#caf-tab,
#admin-tab {
  max-width: 100vw;
  overflow-x: hidden;
}

/* Make sure tab bar doesn‚Äôt cause overflow */
.tabs {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}

/* üß± Fix horizontal wobble on UFL WORLD tab */
#world-tab {
  overflow-x: hidden;
  max-width: 100vw;
}

#world-tab * {
  box-sizing: border-box;
  max-width: 100%;
}

/* Prevent champion card and rows from stretching too wide */
#world-tab .champion-card {
  width: 100%;
  overflow-x: hidden;
}

/* üü° Player rows and headers now use grid (no wrap needed) */
#world-tab .player-header-row,
#world-tab .player-row {
  display: grid;
  grid-template-columns: 48px 1fr 80px 80px; /* Rank | Fighter | Points | Record */
  align-items: center;
  text-align: left;
  gap: 6px;
}

/* Prevent rank columns and side sections from forcing overflow */
#world-tab .rank-num,
#world-tab .players-column-left,
#world-tab .players-column-right {
  min-width: 0;
}

/* Responsive adjustment for smaller screens */
@media (max-width: 600px) {
  #world-tab .player-header-row,
  #world-tab .player-row {
    grid-template-columns: 36px 1fr 60px 60px;
  }
}

/* üéØ Force record and points columns to align evenly */
#world-tab .player-row > .players-column-right:nth-last-child(2),
#world-tab .player-row > .players-column-right:last-child {
  text-align: right;
  justify-self: end;
  width: 80px;
}

/* Keep fighter name area flexible but contained */
#world-tab .players-column-left {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Ensure consistent grid alignment for headers too */
#world-tab .player-header-row > div {
  text-align: right;
}
#world-tab .player-header-row > div:first-child {
  text-align: center;
}
#world-tab .player-header-row > div:nth-child(2) {
  text-align: left;
}


/* üß© FINAL FIX ‚Äì lock UFL WORLD row alignment */
#world-tab .player-row {
  display: grid !important;
  grid-template-columns: 40px 1fr 70px 70px; /* Rank | Name | Points | Record */
  align-items: center;
  gap: 6px;
}

#world-tab .player-header-row {
  display: grid !important;
  grid-template-columns: 40px 1fr 70px 70px;
  align-items: center;
  gap: 6px;
  font-weight: 700;
  color: var(--gold);
}

/* Columns: */
#world-tab .rank-num {
  text-align: center;
}

#world-tab .players-column-left {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#world-tab .players-column-right {
  text-align: right;
  justify-self: end;
  width: 70px;
}

/* Responsive tweak for smaller screens */
@media (max-width: 600px) {
  #world-tab .player-row,
  #world-tab .player-header-row {
    grid-template-columns: 32px 1fr 60px 60px;
  }
  #world-tab .players-column-right {
    width: 60px;
  }
}

/* üéØ Enforce perfect alignment on all ranking rows */
#world-tab .player-row,
#world-tab .player-header-row {
  display: grid;
  grid-template-columns: 40px 1fr 70px 70px;
  align-items: center;
  gap: 6px;
  text-align: left;
}

#world-tab .player-points,
#world-tab .player-record {
  text-align: right;
  justify-self: end;
}

/* üéØ Perfect alignment for UFL WORLD ranking rows (no points column) */
#world-tab .fighter-row {
  display: grid;
  grid-template-columns: 48px 1fr 80px; /* Rank | Name | Record */
  align-items: center;
  gap: 6px;
  text-align: left;
}

#world-tab .rank-num {
  text-align: center;
}

#world-tab .fighter-record {
  text-align: right;
  justify-self: end;
  width: 80px;
}

#world-tab .fighter-name {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Match header row for alignment consistency */
#world-tab .player-header-row {
  display: grid;
  grid-template-columns: 48px 1fr 80px;
  align-items: center;
  gap: 6px;
  color: var(--gold);
  font-weight: 700;
}

/* Responsive adjustment for smaller screens */
@media (max-width: 600px) {
  #world-tab .fighter-row,
  #world-tab .player-header-row {
    grid-template-columns: 36px 1fr 70px;
  }
  #world-tab .fighter-record {
    width: 70px;
  }
}

/* Make Admin dashboard stack to single column on smaller screens */
@media (max-width: 900px) {
  /* target the grid container which currently uses inline style display:grid */
  #admin-dashboard > div[style*="display:grid"] {
    grid-template-columns: 1fr !important;
  }

  /* Ensure any element using grid-column:span 2 stops spanning and just stacks */
  #admin-dashboard > div[style*="display:grid"] .frosted[style*="grid-column:span 2"] {
    grid-column: auto !important;
  }

  /* small spacing tweak so stacked cards don't feel cramped */
  #admin-dashboard > div[style*="display:grid"] .frosted {
    width: 100%;
  }
}

/* ü•ã Make CAF Player Cards look identical to WORLD */
#caf-tab .modal,
.player-card-overlay .modal {
  background: rgba(6,6,6,0.94);
  color: #fff;
  border-radius: 10px;
  padding: 16px;
  border: 1px solid rgba(255,215,0,0.08);
  box-shadow: 0 0 20px rgba(0,0,0,0.4);
}

.player-card-overlay .fights-row {
  display: grid;
  grid-template-columns: 100px 1fr 120px 140px;
  gap: 14px;
  align-items: center;
  width: 100%;
  padding: 8px 0;
  border-bottom: 1px solid rgba(255,255,255,0.05);
  font-size: 14px;
}

.player-card-overlay .fights-row div:first-child {
  color: var(--muted);
}

.player-card-overlay .fights-row div:nth-child(2) {
  font-weight: 600;
  color: #fff;
}

.player-card-overlay .fights-row div:nth-child(3),
.player-card-overlay .fights-row div:nth-child(4) {
  text-align: right;
  color: var(--muted);
}

.player-card-overlay .badge {
  font-size: 14px;
}


/* ===== CAF / player card modal ‚Äî force-match WORLD styling ===== */
.player-card-overlay,
.modal-backdrop,
#fighter-modal,
.player-card,
.player-card .modal,
.player-card-overlay .modal,
.modal-backdrop .modal,
#fighter-modal .modal,
#fighter-modal .player-card,
.player-card-overlay .player-card,
.frosted.player-card,
.modal {
  background: rgba(6,6,6,0.94) !important;
  color: #fff !important;
  border-radius: 10px !important;
  padding: 16px !important;
  border: 1px solid rgba(255,215,0,0.08) !important;
  box-shadow: 0 0 20px rgba(0,0,0,0.4) !important;
}

/* fights-row grid style for any fights-row inside any modal/backdrop */
.player-card-overlay .fights-row,
.modal-backdrop .fights-row,
.player-card .fights-row,
#fighter-modal .fights-row,
.modal .fights-row {
  display: grid !important;
  grid-template-columns: 100px 1fr 120px 140px !important;
  gap: 14px !important;
  align-items: center !important;
  width: 100% !important;
  padding: 8px 0 !important;
  border-bottom: 1px solid rgba(255,255,255,0.05) !important;
  font-size: 14px !important;
}

.player-card-overlay .fights-row div:first-child,
.modal-backdrop .fights-row div:first-child,
.modal .fights-row div:first-child {
  color: var(--muted) !important;
}

.player-card-overlay .fights-row div:nth-child(2),
.modal .fights-row div:nth-child(2) {
  font-weight: 600 !important;
  color: #fff !important;
}

.player-card-overlay .fights-row div:nth-child(3),
.player-card-overlay .fights-row div:nth-child(4),
.modal .fights-row div:nth-child(3),
.modal .fights-row div:nth-child(4) {
  text-align: right !important;
  color: var(--muted) !important;
}

.player-card-overlay .badge,
.modal .badge,
.player-card .badge,
.player-card-overlay .player-card .badge {
  font-size: 14px !important;
}


/* üèÜ CHAMPION badge glow effect */
.badge.glow {
  background: radial-gradient(circle at center, gold 0%, rgba(255, 215, 0, 0.3) 60%, transparent 100%);
  color: #000;
  font-weight: bold;
  box-shadow: 0 0 10px gold, 0 0 20px rgba(255, 215, 0, 0.8);
  border: 1px solid rgba(255, 215, 0, 0.7);
}


/* =========================
   LEGACY MODAL (ISOLATED)
   ========================= */
   .legacy-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.legacy-modal {
  background: #0b0b0f;
  width: 900px;
  max-height: 90vh;
  border-radius: 14px;
  padding: 24px;
  overflow-y: auto;
  box-shadow: 0 0 40px rgba(212,175,55,0.25);
  color: #f5f5f5;
}

.legacy-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid rgba(212,175,55,0.25);
  padding-bottom: 12px;
}

.legacy-name {
  font-size: 28px;
  font-weight: 800;
  color: #d4af37;
}

.legacy-sub {
  font-size: 13px;
  color: var(--muted);
}

.legacy-section {
  margin-top: 20px;
}

.legacy-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit,minmax(160px,1fr));
  gap: 12px;
}

.legacy-stat {
  background: #141418;
  border-radius: 10px;
  padding: 12px;
  text-align: center;
}

.legacy-tabs {
  display: flex;
  gap: 6px;
  margin-top: 24px;
}

.legacy-tab {
  background: #141418;
  border: 1px solid #222;
  padding: 8px 14px;
  border-radius: 20px;
  cursor: pointer;
}

.legacy-tab.active {
  background: #d4af37;
  color: #000;
  font-weight: 700;
}

.legacy-content {
  margin-top: 16px;
}

.legacy-click {
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.legacy-click:hover {
  transform: translateY(-2px);
  box-shadow: 0 0 12px rgba(212,175,55,0.35);
}

.defense-row {
  display: grid;
  grid-template-columns: 120px 1fr 1fr;
  gap: 12px;
  padding: 10px 0;
  border-bottom: 1px solid #222;
}

.defense-row strong {
  color: #d4af37;
}

.legacy-record-header{
  font-size: 15px;
  font-weight: 800;
  letter-spacing: 0.3px;
  padding: 10px 12px;
  border-radius: 10px;
  background: rgba(212,175,55,0.10);
  border: 1px solid rgba(212,175,55,0.20);
  margin-bottom: 10px;
}

.legacy-record-header strong{
  color: var(--gold);
}


/* ‚úÖ ADMIN tab: force readable text in ALL inputs/textareas/selects */
#admin-tab textarea,
#admin-tab input,
#admin-tab select {
  color: #ffffff !important;
  caret-color: #ffffff !important;
  background: rgba(0,0,0,0.75) !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
}

#admin-tab textarea::placeholder,
#admin-tab input::placeholder {
  color: rgba(255,255,255,0.55) !important;
}


#loading-overlay{
  position:fixed;
  inset:0;
  z-index:99999;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.75);
  backdrop-filter: blur(6px);
}
#loading-overlay.hidden{ display:none; }

#loading-overlay .loading-box{
  padding:18px 22px;
  border:1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.45);
  border-radius:14px;
  text-align:center;
}
#loading-overlay .loading-text{
  margin-top:10px;
  font-weight:700;
  letter-spacing:0.5px;
}

#loading-overlay .spinner{
  width:28px;
  height:28px;
  border-radius:50%;
  border:3px solid rgba(255,255,255,0.25);
  border-top-color: rgba(255,255,255,0.95);
  margin:0 auto;
  animation: spin 0.9s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }


</style>
</head>
<body>


<div id="loading-overlay">
<div class="loading-box">
  <div class="spinner"></div>
  <div class="loading-text">Loading UFL‚Ä¶</div>
</div>
</div>


  <div style="
  background:black;
  padding:15px 0;
  display:flex;
  justify-content:center;
">
  <img
    src="https://github.com/undisputedfightleague/ufl-assets/blob/main/Untitled-1.png?raw=true"
    alt="UFL LOGO"
    style="max-width:320px; width:100%; display:block;"
  />
</div>

  <div class="container">
    <div class="frosted" style="margin-bottom:12px;">

      <div class="submuted">HOME OF THE BEST</div>
    </div>
<!-- END Part 1 of 6 -->
<!-- START Part 2 of 6 -->

<div class="tabs" role="tablist" aria-label="Main tabs">
  <!-- üè† HOME button (new) -->
  <button id="btn-home" class="tab-btn" onclick="switchTab('home')">
    <i class="fas fa-home"></i>&nbsp;HOME
  </button>

  <button id="btn-world" class="tab-btn tab-active" onclick="switchTab('world')">
    <i class="fas fa-globe-americas"></i>&nbsp;UFL WORLD
  </button>

  <button id="btn-rbc" class="tab-btn" onclick="switchTab('rbc')">
    <i class="fas fa-flag"></i>&nbsp;RBC
  </button>

  <button id="btn-abc" class="tab-btn" onclick="switchTab('abc')">
    <i class="fas fa-star"></i>&nbsp;ABC
  </button>


  
 
  <button id="btn-fights" class="tab-btn" onclick="switchTab('fights')">
    <i class="fas fa-list"></i>&nbsp;FIGHTS
  </button>

  <button id="btn-legacy" class="tab-btn" onclick="switchTab('legacy')">
    <i class="fas fa-landmark"></i>&nbsp;LEGACY
  
  
  </button>
  


  <button id="btn-admin" class="tab-btn" onclick="switchTab('admin')">
    <i class="fas fa-lock"></i>&nbsp;ADMIN
  </button>
  
</div>


<div class="frosted">
  <!-- WORLD TAB -->

<!-- üè† HOME TAB -->
<div id="home-tab" class="tab-content">


  <h1>FEATURED EVENT</h1>

  <div style="display:flex; justify-content:center;">

  <iframe 
width="300" 
height="180" 
src="https://www.youtube.com/embed/eFeunqTcUDA?si=nY_r4TBYzlsgtM4t"
frameborder="0" 
allowfullscreen>
</iframe>
</div>




<br> </br> 

  <h1>UFL RANKINGS BREAKDOWN</h1>
  

  <ul style="list-style:none;padding:0;">
    <br>
    <li><b>BASE SCORING</b></li>
    <li>Win: +2 Points</li>
    <li>Draw: +1 Point</li>
    <li>Loss: ‚àí1.5 Points (increases by ‚àí0.5 for each consecutive loss)</li>
    
    <br></br>
    
    <li><b>FINISH BONUS</b></li>
    <li>KO / TKO Win: +1 Point</li>
    
    <br></br>
    
    <li><b>OPPONENT RANK IMPACT</b></li>
    <li>Win vs Top 5 opponent: +3 Points</li>
    <li>Win vs Top 10 opponent: +2 Points</li>
    <li>Win vs Top 20 opponent: +1 Point</li>
    <li>Only applies if opponent has 6 or more total fights</li>
    <li>Loss penalties for bad losses:</li>
    <li>‚Ä¢ Top 5 fighter losing to #11‚Äì#50: ‚àí2 additional points</li>
    <li>‚Ä¢ Top 10 fighter losing to #11‚Äì#50: ‚àí1 additional point</li>
    
    <br></br>
    
    <li><b>RECENCY BONUS</b></li>
    <li>Fights within the last 20 days receive a 15% score increase</li>
    
    <br></br>
    
    <li><b>WIN STREAK MOMENTUM</b></li>
    <li>After 3 consecutive wins, each additional win earns +1 point</li>
    <li>Streak bonus capped at +5 points</li>
    
    <br></br>
    
    <li><b>INACTIVITY DECAY</b></li>
    <li>After 20 days without a fight, total points decay by 0.5% per day</li>
    <li>Maximum inactivity decay capped at 15%</li>
    
    <br></br>
    
    <li><b>INTERCONTINENTAL (IC) FIGHTS</b></li>
    <li>IC Win: +1 Point</li>
    <li>IC KO / TKO Win: +0.5 Bonus</li>
    <li>IC Loss: ‚àí1 Point</li>
    <li>IC fights ignore all other ranking modifiers</li>
    
  
</div>


  <div id="world-tab" class="tab-panel">
    <div class="grid-main">
      <div>
        <div id="world-champion-card" class="champion-card"></div>
      </div>
      <div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <h2 style="margin:0;font-family:Orbitron;">UFL WORLD RANKINGS</h2>
          <input
          id="world-search"
          placeholder="Search..."
          oninput="renderAll()"
          onkeyup="renderAll()"
          class="frosted"
          style="padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);font-size:14px;color:#fff;background:rgba(0,0,0,0.4);"
        />
        
        </div>
        <div id="world-rankings" class="rank-list"></div>
         
      </div>
    </div>
  </div>

<!-- üè¥‚Äç‚ò†Ô∏è RBC TAB -->
<div id="rbc-tab" class="tab-panel hidden" style="margin-top:14px;">
  <div class="grid-main">
    <div>
      <div id="rbc-champion-card" class="champion-card"></div>
    </div>
    <div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h2 style="margin:0;font-family:Orbitron;">RBC TOP 15</h2>
        
      </div>
      <div id="rbc-rankings" class="rank-list"></div>
    </div>
  </div>
</div>

<!-- ü¶Ö ABC TAB -->
<div id="abc-tab" class="tab-panel hidden" style="margin-top:14px;">
  <div class="grid-main">
    <div>
      <div id="abc-champion-card" class="champion-card"></div>
    </div>
    <div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h2 style="margin:0;font-family:Orbitron;">ABC TOP 15</h2>
      </div>
      <div id="abc-rankings" class="rank-list"></div>
    </div>
  </div>
</div>

  





  <!-- FIGHTS TAB -->
  <div id="fights-tab" class="tab-panel hidden" style="margin-top:14px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <h2 style="margin:0;font-family:Orbitron;">FIGHTS</h2>
      <div><input id="fights-search" placeholder="Search fights..." oninput="renderFights()" /><button class="btn" onclick="renderFights()">Search</button></div>
    </div>



    <div id="fights-list" style="max-height:640px; overflow:auto;"></div>
  </div>

  <div id="legacy-tab" class="tab-panel hidden">

    <h2 style="font-family:Orbitron;">üèõÔ∏è UFL LEGACY</h2>
    <div class="small-muted" style="margin-bottom:14px;">
      Cross-season records, championship history, and Hall of Fame
    </div>
  
    <div class="frosted" style="margin-bottom:16px;">
      <h3>Legacy Fighters</h3>

      <div style="display:flex; gap:8px; align-items:center; margin:10px 0;">
        <input id="legacy-search" class="input" style="flex:1;"
               placeholder="Search fighters..."
               oninput="renderLegacyFighterList?.()" />
        <button class="btn" onclick="document.getElementById('legacy-search').value=''; renderLegacyFighterList?.();">
          Clear
        </button>
      </div>
      

      <div id="legacy-fighter-list" class="legacy-grid">
        <!-- Legacy fighter rows injected here -->
      </div>
    </div>
  
  </div>
  

  <!-- ADMIN TAB -->
  <div id="admin-tab" class="tab-panel hidden" style="margin-top:14px;">
    <div id="admin-login" class="frosted">
      <h3 style="margin:0;font-family:Orbitron;">Admin Login</h3>
      <div class="small-muted">Enter admin password to unlock admin tools.

      </div>
      <div style="margin-top:10px;">
        <input id="admin-pass" type="password" placeholder="Admin password" />
        <div style="margin-top:8px;"><button class="btn btn-primary" onclick="attemptAdminLogin()">Login</button></div>
        <div id="admin-login-error" class="small-muted" style="color:#f87171;display:none;margin-top:8px;"></div>
      </div>
    </div>

    <div id="admin-dashboard" class="hidden" style="margin-top:12px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
        <h2 style="margin:0;font-family:Orbitron;">Admin Dashboard</h2>
        <div style="display:flex;gap:8px;align-items:center;"><span class="small-muted">Logged in</span>
          <div style="display:flex;gap:8px;"><button class="btn btn-danger" onclick="logoutAdmin()">Logout</button></div></div>
      </div>

      <div class="admin-grid">

        <hr style="margin:8px 0;">
        <h4 style="margin:6px 0;">Add Fighter</h4>
        <div style="display:flex;gap:8px;align-items:center;">
          <input id="add-fighter-name" placeholder="Name" style="flex:1;" />
          <select id="add-fighter-region">
            <option value="NA">NA</option>
            <option value="EU">EU</option>
          </select>
          <button class="btn btn-primary" onclick="adminAddFighter()">Add</button>
        </div>
      </div>

      <!-- ü•ä MATCHMAKING ASSISTANT -->
<div class="frosted" style="margin-top:16px;">
  <h3 style="margin:0 0 8px 0;">Matchmaking Assistant</h3>
  <div class="small-muted">Select a fighter to get 3 suggested fair-match opponents.</div>

  <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
    <select id="matchmaking-select" style="flex:1; padding:8px; border-radius:6px;"></select>
    <button class="btn btn-primary" onclick="runMatchmaking()">Suggest</button>
  </div>

  <div id="matchmaking-results" style="margin-top:12px;"></div>
</div>

        <!-- ü•ä ADD FIGHT SECTION -->
        <div id="add-fight-section" class="admin-section">
          <h3 class="text-xl font-bold mb-3">Add Fight</h3>
        
          <!-- FIGHTER 1 -->
          <div class="form-group mb-2">
            <label for="add-fight-f1" class="block text-sm font-semibold mb-1">FIGHTER 1</label>
            <select id="add-fight-f1" class="form-control w-full p-1 border rounded"></select>
          </div>
        
          <!-- FIGHTER 2 -->
          <div class="form-group mb-2">
            <label for="add-fight-f2" class="block text-sm font-semibold mb-1">FIGHTER 2</label>
            <select id="add-fight-f2" class="form-control w-full p-1 border rounded"></select>
          </div>
        
         <!-- METHOD -->
        <div class="form-group mb-2">
          <label for="add-fight-method" class="block text-sm font-semibold mb-1">METHOD</label>
          <select id="add-fight-method" class="form-control w-full p-1 border rounded">
            <option value="ko">KO / TKO</option>
            <option value="decision">Decision</option>
            <option value="draw">Draw</option>
          </select>
        </div>
        
        
        <!-- WINNER -->
        <div class="form-group mb-2">
          <label for="add-fight-winner" class="block text-sm font-semibold mb-1">WINNER</label>
          <select id="add-fight-winner" class="form-control w-full p-1 border rounded">
            <option value="">Select Winner</option>
            <option value="draw">Draw</option>
          </select>
        </div>
        
          <!-- DATE -->
          <div class="form-group mb-2">
            <label for="add-fight-date" class="block text-sm font-semibold mb-1">DATE</label>
            <input id="add-fight-date" type="date" class="form-control w-full p-1 border rounded" />
          </div>
        
      
        
          <!-- TITLE FIGHT -->
          <div class="form-group mb-2">
            <label for="add-fight-titlefight" class="block text-sm font-semibold mb-1">TITLE FIGHT</label>
            <select id="add-fight-titlefight" class="form-control w-full p-1 border rounded">
              <option value="no">No</option>
              <option value="yes">Yes</option>
            </select>
          </div>

          <!-- IC FIGHT -->
<div class="form-group mb-2">
  <label for="add-fight-ic" class="block text-sm font-semibold mb-1">IC</label>
  <select id="add-fight-ic" class="form-control w-full p-1 border rounded">
    <option value="no">No</option>
    <option value="yes">Yes</option>
  </select>
</div>

        
          <!-- BONUS -->
          <div class="form-group mb-4">
            <label for="add-fight-bonus" class="block text-sm font-semibold mb-1">BONUS</label>
            <select id="add-fight-bonus" class="form-control w-full p-1 border rounded">
              <option value="none">NONE</option>
              <option value="FOTN">FOTN (Fight of the Night)</option>
            </select>
          </div>
        
          <!-- SUBMIT BUTTON -->
          <button onclick="adminAddFight()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-4 rounded">
            Add Fight
          </button>
        </div>



        <div class="frosted">
          <h3 style="margin:0 0 8px 0;">Manage Fighters</h3>
          <div class="small-muted">Edit names, platform, retire/unretire. Points column shows calculated ranking points (combined names).</div>
          <div style="margin-top:8px;">
            
            <table>
              <thead><tr><th>Name</th><th>Platform</th><th>Actions</th></tr></thead>
              <tbody id="admin-fighters-list"></tbody>
            </table>
            

          </div>
    

        <div class="frosted">
          <h3 style="margin:0 0 8px 0;">Manage Fights</h3>
          <div class="small-muted">Select fight by input order to edit or delete (admin only).</div>
          <div style="margin-top:8px;">
            <select id="admin-fights-dropdown" style="width:100%; padding:8px; border-radius:6px;"></select>
            <div style="margin-top:8px; display:flex; gap:8px;">
              <button class="btn btn-primary" onclick="adminEditSelectedFight()">Edit Selected</button>
              <button class="btn btn-danger" onclick="adminDeleteSelectedFight()">Delete Selected</button>
            </div>
            <div id="admin-fights-list" style="margin-top:10px; max-height:240px; overflow:auto;"></div>
          </div>
          <hr style="margin:8px 0;">
          <h4 style="margin:6px 0;">Add Fight</h4>
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;align-items:center;">
           
  

</div>

<script>
  function updateWinnerDropdown() {
    const f1Select = document.getElementById('add-fight-f1');
    const f2Select = document.getElementById('add-fight-f2');
    const winnerSelect = document.getElementById('add-fight-winner');
  
    if (!f1Select || !f2Select || !winnerSelect) return;
  
    const f1Name = f1Select.options[f1Select.selectedIndex]?.text || '';
    const f2Name = f2Select.options[f2Select.selectedIndex]?.text || '';
  
    // Clear current options
    winnerSelect.innerHTML = '';
  
    // Add updated fighter options
    if (f1Name) {
      const opt1 = document.createElement('option');
      opt1.value = f1Select.value;
      opt1.textContent = f1Name + ' (Fighter 1)';
      winnerSelect.appendChild(opt1);
    }
  
    if (f2Name) {
      const opt2 = document.createElement('option');
      opt2.value = f2Select.value;
      opt2.textContent = f2Name + ' (Fighter 2)';
      winnerSelect.appendChild(opt2);
    }
  
    // Add draw option
    const drawOpt = document.createElement('option');
    drawOpt.value = '0';
    drawOpt.textContent = 'Draw';
    winnerSelect.appendChild(drawOpt);
  }
  
  // Listen for changes on Fighter 1 and Fighter 2 dropdowns
  document.getElementById('add-fight-f1')?.addEventListener('change', updateWinnerDropdown);
  document.getElementById('add-fight-f2')?.addEventListener('change', updateWinnerDropdown);
  </script>
  

 

        <div class="frosted" style="grid-column:span 2;">
          <h3 style="margin:0 0 8px 0;">Champion Titles Management</h3>
          <div class="small-muted">Assign UFL & RBC titles. UFL World & CAF show Title Defenses (editable) and Last Defense (read-only). Vacate clears title and resets counters for UFL titles.</div>
          <div id="champion-titles-container" style="margin-top:10px; display:grid; grid-template-columns: 1fr 1fr; gap:10px;"></div>
          <div style="margin-top:10px; display:flex; gap:8px;">
            <button class="btn btn-yellow" onclick="saveChampionAssignments()">Save Titles</button>
            <button class="btn" onclick="resetChampionAssignments()">Clear Titles</button>
            <button class="btn" onclick="refreshRankings()">üîÑ Refresh Rankings</button>
          </div>

          <div class="frosted" style="margin-top:12px; grid-column:span 2;">
            <h3 style="margin:0 0 8px 0;">LEGACY TOOLS</h3>
            <div class="small-muted">
              Paste Season 1 records (tab, pipe, or CSV). Format: PLAYER NAME | WIN | LOSS | DRAW | SEASON
            </div>
          
            <textarea id="legacy-s1-input" class="input"
              style="width:100%; height:170px; margin-top:8px;"
              placeholder="PLAYER NAME\tWIN\tLOSS\tDRAW\tSEASON
          Donny\t12\t3\t1\t1"></textarea>
          
            <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;">
              <button class="btn btn-yellow" onclick="importSeason1Records()">Import Season 1 Records</button>
              <button class="btn" onclick="loadSeason1RecordsToBox()">Load Current S1 Records</button>
              <button class="btn btn-danger" onclick="clearSeason1Records()">Clear S1 Records</button>
            </div>
          
            <div class="small-muted" style="margin-top:8px;">
              Stored in Firestore at <code>settings/legacyS1</code>. Matching is by lowercased fighter name.
            </div>
          </div>
          
          <div class="frosted" style="margin-top:12px; grid-column:span 2;">
            <h3 style="margin:0 0 8px 0;">LEGACY ‚Äî CHAMPION HISTORY</h3>
            <div class="small-muted">Add/edit title reigns & defenses. These power Titles/Defenses in LEGACY modals.</div>

            <div style="display:flex; gap:8px; align-items:flex-end; flex-wrap:wrap; margin-top:10px;">
              <div style="flex:1; min-width:260px;">
                <label class="small-muted">Edit Existing Reign</label>
                <select id="reign-select" class="input" style="width:100%;" onchange="loadSelectedLegacyReign()">
                  <option value="">-- New Reign --</option>
                </select>
              </div>
            
              <button class="btn" onclick="clearLegacyReignForm()">New</button>
              <button class="btn btn-danger" onclick="deleteSelectedLegacyReign()">Delete</button>
            </div>
            
          
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px;">
              <div>
                <label class="small-muted">Fighter Name</label>
                <input id="reign-fighter" class="input" placeholder="Donny" />
              </div>
          
              <div>
                <label class="small-muted">Title</label>
                <input id="reign-title" class="input" placeholder="UFL World" />
              </div>
          
              <div>
                <label class="small-muted">Season</label>
                <input id="reign-season" type="number" class="input" value="2" min="1" max="3" />
              </div>
          
              <div>
                <label class="small-muted">Won Date</label>
                <input id="reign-won" type="date" class="input" />
              </div>
          
              <div>
                <label class="small-muted">Lost Date (optional)</label>
                <input id="reign-lost" type="date" class="input" />
              </div>
            </div>
          
            <label class="small-muted" style="display:block; margin-top:10px;">Defenses (one per line)</label>
            <div class="small-muted">Format: YYYY-MM-DD | Opponent | Event | Method</div>
            <textarea id="reign-defenses" class="input" style="width:100%; height:130px; margin-top:6px;"
              placeholder="2024-08-12 | Ipro | UFL Fight Night 18 | TKO (R5)"></textarea>
          
            <div style="display:flex; gap:8px; margin-top:10px; flex-wrap:wrap;">
              <button class="btn btn-yellow" onclick="saveLegacyReign()">Save Reign</button>
            </div>
          </div>
          
          <div class="admin-section">
          <h3>üèõÔ∏è Legacy Import (Season 2)</h3>
        
          <textarea id="legacyFightersInput"
            placeholder="Paste Season 2 fighters JSON here"></textarea>
        
          <textarea id="legacyFightsInput"
            placeholder="Paste Season 2 fights JSON here"></textarea>
        
          <button onclick="importSeason2Legacy()">
            Import Season 2 Legacy Data
          </button>
        </div>
          <button class="btn" style="margin-top:10px;"
          onclick="openLegacyFighterModal(mockLegacyFighter)">
          üß™ Open Legacy Fighter Modal (DEV)
        </button>
        
        <div class="admin-section" style="margin-top:14px;">
          <h3>‚úçÔ∏è Legacy Manual Entry (Season Record Override)</h3>
          <div class="small-muted" style="margin-bottom:10px;">
            Use this if a fighter is missing or if you need to correct a season record manually.
            This does not touch Season 3 live fights‚ÄîLEGACY only.
          </div>
        
          <input id="legacy-manual-name" class="input" style="width:100%;"
            placeholder="Fighter name (must match how you want it displayed)" />
        
            <div style="display:grid; grid-template-columns: 140px 80px 80px 80px; gap:8px; margin-top:8px; align-items:center;">
              <select id="legacy-manual-season" class="input" style="width:140px;">
                <option value="1">Season 1</option>
                <option value="2">Season 2</option>
                <option value="3">Season 3</option>
              </select>
            
              <input id="legacy-manual-w" class="input" type="number" min="0" placeholder="W" />
              <input id="legacy-manual-l" class="input" type="number" min="0" placeholder="L" />
              <input id="legacy-manual-d" class="input" type="number" min="0" placeholder="D" />
            </div>
            
            <div style="display:flex; gap:8px; margin-top:10px; flex-wrap:wrap;">
              <button class="btn btn-yellow" onclick="saveLegacyManualRecord()">Save</button>
              <button class="btn" onclick="loadLegacyManualRecord()">Load</button>
              <button class="btn btn-danger" onclick="deleteLegacyManualRecord()">Delete</button>
            </div>
            
        
          <div class="small-muted" style="margin-top:8px;">
            Tip: ‚ÄúLoad‚Äù pulls any existing manual entry so you can edit it safely.
          </div>
        </div>

          <div class="breakdown" id="ranking-breakdown" style="margin-top:14px;">
            <div style="font-weight:700;color:var(--gold);margin-bottom:6px;">RANKING POINTS BREAKDOWN</div>
            <div>- Base: <strong>Wins +3</strong>, <strong>Losses ‚àí1 (escalates)</strong>, <strong>Draws +1</strong></div>
            <div>- Title Capture: <strong>+2</strong></div>
            <div>- Title Defense: <strong>+3</strong></div>
            <div>- Championship Fight Multiplier: <strong>√ó1.5</strong></div>
            <div>- Defense Fight Multiplier: <strong>√ó1.5</strong></div>
            <div>- Contender Multiplier (Top 10 vs Top 10): <strong>√ó1.25</strong></div>
            <div>- Opponent Strength Bonus: Weighted by opponent win %</div>
            <div>- Recency Bonus: <strong>√ó1.2</strong> for fights within the last 10 days</div>
            <div style="margin-top:8px;font-size:12px;color:var(--muted)">Decay: Fighters who haven't fought in 10+ days lose 1% per day (capped at 20%).</div>
          </div>

        </div>
      </div>
    </div>
  </div>
</div><!-- frosted -->
</div><!-- container -->

<!-- Fighter modal -->
<div id="fighter-modal" class="hidden modal-backdrop" aria-hidden="true">
<div class="modal" id="fighter-modal-content" style="max-width:900px;">
  <!-- content filled dynamically -->
</div>
</div>

<!-- Edit fight modal (admin) -->
<div id="edit-fight-modal" class="hidden modal-backdrop" aria-hidden="true">
<div class="modal" style="max-width:520px;">
  <div style="display:flex;justify-content:space-between;align-items:center;">
    <h3 style="margin:0;font-family:Orbitron;">Edit Fight</h3>
    <button class="btn" onclick="closeEditFightModal()">‚úñ</button>
  </div>
  <div style="margin-top:8px;">
    <label class="small-muted">Fighter 1</label><br>
    <select id="edit-fight-f1" class="input" style="width:100%;"></select>
    <label class="small-muted" style="margin-top:6px;">Fighter 2</label><br>
    <select id="edit-fight-f2" class="input" style="width:100%;"></select>
    <label class="small-muted" style="margin-top:6px;">Platform</label><br>
    


    <label class="small-muted" style="margin-top:6px;">Method</label><br>
    <select id="edit-fight-method" class="input" style="width:100%;"><option>KO/TKO</option><option>Decision</option><option>Draw</option></select>
    <label class="small-muted" style="margin-top:6px;">Winner</label><br>
    <select id="edit-fight-winner" class="input" style="width:100%;"><option value="0">Draw</option></select>
    <label class="small-muted" style="margin-top:6px;">Date</label><br>
    <input id="edit-fight-date" type="date" class="input" />
    <label class="small-muted" style="margin-top:6px;">CAF fight?</label><br>
    <select id="edit-fight-caf" class="input" style="width:100%;"><option value="false">No</option><option value="true">Yes</option></select>

    <div style="display:flex;gap:8px;margin-top:10px;">
      <button class="btn btn-primary" onclick="saveEditedFight()">Save</button>
      <button class="btn btn-danger" onclick="confirmDeleteFight()">Delete</button>
    </div>
  </div>
</div>
</div>

<!-- LEGACY FIGHTER MODAL (DEV / READ-ONLY) -->
<div id="legacy-modal-backdrop" class="legacy-backdrop hidden">
  <div class="legacy-modal">

    <div class="legacy-header">
      <div>
        <div class="legacy-name" id="legacy-name">Fighter Name</div>
        <div class="legacy-sub" id="legacy-sub">Seasons: S1 ‚Ä¢ S2 ‚Ä¢ S3</div>
      </div>
      <button class="legacy-close" onclick="closeLegacyFighterModal()">‚úñ</button>
    </div>

    <div class="legacy-section">
      <h3>Career Summary</h3>
      <div class="legacy-stats" id="legacy-summary"></div>
    </div>

    <div class="legacy-tabs">
      <button class="legacy-tab active" onclick="switchLegacyTab('career')">Career</button>
      <button class="legacy-tab" onclick="switchLegacyTab('s1')">Season 1</button>
      <button class="legacy-tab" onclick="switchLegacyTab('s2')">Season 2</button>
      <button class="legacy-tab" onclick="switchLegacyTab('s3')">Season 3</button>
    </div>

    <div class="legacy-content" id="legacy-content"></div>

  </div>
</div>

<!-- TITLE DEFENSE HISTORY MODAL --> <div id="defense-modal-backdrop" class="legacy-backdrop hidden"> <div class="legacy-modal" style="max-width:700px;"> <div class="legacy-header"> <div class="legacy-name">Title Defense History</div> <button class="legacy-close" onclick="closeDefenseHistoryModal()">‚úñ</button> </div> <div class="legacy-content" id="defense-history-list"></div> </div> </div>

<!-- TITLE REIGNS MODAL -->
<div id="reigns-modal-backdrop" class="legacy-backdrop hidden">
  <div class="legacy-modal" style="max-width:760px;">

    <div class="legacy-header">
      <div class="legacy-name">Title Reigns</div>
      <button class="legacy-close" onclick="closeTitleReignsModal()">‚úñ</button>
    </div>

    <div class="legacy-content" id="reigns-history-list"></div>

  </div>
</div>











<!-- END Part 2 of 6 -->
<!-- START Part 3 of 6 -->
<script>
  /* ===========================
     üî• FIREBASE INITIALIZATION
     =========================== */
     const firebaseConfig = {
  apiKey: "AIzaSyBkcyte__qrs-sxQilqjK40Wl5NDJARxzU",
  authDomain: "ufl-season-3.firebaseapp.com",
  projectId: "ufl-season-3",
  storageBucket: "ufl-season-3.firebasestorage.app",
  messagingSenderId: "148274309173",
  appId: "1:148274309173:web:335fbe2161af38f9c6e97c"

  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  firebase.firestore().enablePersistence().catch(() => {});
  

  /* ===========================
     üåê GLOBAL STATE & HELPERS
     =========================== */
  let fighters = [];   // raw fighter docs from Firestore
  let fights = [];     // raw fight docs from Firestore
  let champions = {};  // champion assignments from settings/champions doc
  
  let allFights = [];      // ‚úÖ holds S2+S3 for LEGACY later
let season3Fights = [];  // ‚úÖ holds only S3 for current season UI

let legacyS1Records = {}; // key: normalized fighter name -> { w, l, d, season: 1 }

let legacyTitleReigns = []; // array of reign docs

// ‚úÖ Manual legacy overrides (by nameKey, per season)
let legacyManualRecords = {};

// ‚úÖ Legacy-only fighter names (so Season 1-only people can appear on the list)
let legacyExtraFighters = [];

let _fightersLoaded = false;
let _fightsLoaded = false;

function setLoading(isLoading){
  const el = document.getElementById('loading-overlay');
  if (!el) return;
  el.classList.toggle('hidden', !isLoading);
}


// Listen for manual overrides
db.collection('settings').doc('legacyManualRecords').onSnapshot(doc => {
  const data = doc.exists ? doc.data() : {};
  legacyManualRecords = data.records || {};
  if (_legacyActive) renderLegacyFighterList?.();
}, e => console.warn('legacyManualRecords listener', e));

// Listen for extra legacy-only fighters
db.collection('settings').doc('legacyExtraFighters').onSnapshot(doc => {
  const data = doc.exists ? doc.data() : {};
  legacyExtraFighters = Array.isArray(data.names) ? data.names : [];
  if (_legacyActive) renderLegacyFighterList?.();
}, e => console.warn('legacyExtraFighters listener', e));

function _legacyNameKey(name) {
  return (name || '').trim().toLowerCase();
}

async function _ensureLegacyExtraFighter(name) {
  const clean = (name || '').trim();
  if (!clean) return;
  const ref = db.collection('settings').doc('legacyExtraFighters');
  const snap = await ref.get();
  const existing = snap.exists ? (snap.data().names || []) : [];
  if (existing.some(n => _legacyNameKey(n) === _legacyNameKey(clean))) return;

  const next = [...existing, clean].sort((a,b)=>a.localeCompare(b));
  await ref.set({ names: next }, { merge:true });
}

async function saveLegacyManualRecord() {
  const name = ($('legacy-manual-name')?.value || '').trim();
  const season = parseInt($('legacy-manual-season')?.value || '1', 10);
  const w = parseInt($('legacy-manual-w')?.value || '0', 10) || 0;
  const l = parseInt($('legacy-manual-l')?.value || '0', 10) || 0;
  const d = parseInt($('legacy-manual-d')?.value || '0', 10) || 0;

  if (!name) return alert('Enter a fighter name.');

  const key = _legacyNameKey(name);
  const ref = db.collection('settings').doc('legacyManualRecords');
  const snap = await ref.get();
  const existing = snap.exists ? (snap.data().records || {}) : {};

  const prev = existing[key] || {};
  const next = {
    ...existing,
    [key]: {
      ...prev,
      name, // keep display name
      [season]: { w, l, d }
    }
  };

  await ref.set({ records: next }, { merge:true });

  // ‚úÖ If they are a Season 1-only fighter and not in S3 fighters,
  // this makes sure they show up on the LEGACY list.
  await _ensureLegacyExtraFighter(name);

  alert(`Saved manual LEGACY record for ${name} (S${season} ${w}-${l}-${d}).`);
  if (_legacyActive) renderLegacyFighterList?.();
}

async function loadLegacyManualRecord() {
  const name = ($('legacy-manual-name')?.value || '').trim();
  const season = parseInt($('legacy-manual-season')?.value || '1', 10);
  if (!name) return alert('Enter a fighter name.');

  const key = _legacyNameKey(name);
  const entry = legacyManualRecords?.[key]?.[season] || null;

  $('legacy-manual-w').value = entry ? (entry.w || 0) : 0;
  $('legacy-manual-l').value = entry ? (entry.l || 0) : 0;
  $('legacy-manual-d').value = entry ? (entry.d || 0) : 0;

  alert(entry ? `Loaded manual entry for ${name} (S${season}).` : `No manual entry found for ${name} (S${season}).`);
}

async function deleteLegacyManualRecord() {
  const name = ($('legacy-manual-name')?.value || '').trim();
  const season = parseInt($('legacy-manual-season')?.value || '1', 10);
  if (!name) return alert('Enter a fighter name.');
  if (!confirm(`Delete manual LEGACY record for ${name} (Season ${season})?`)) return;

  const key = _legacyNameKey(name);
  const ref = db.collection('settings').doc('legacyManualRecords');
  const snap = await ref.get();
  const existing = snap.exists ? (snap.data().records || {}) : {};
  const cur = existing[key] || {};
  if (!cur[season]) return alert('No manual entry to delete.');

  const nextKeyObj = { ...cur };
  delete nextKeyObj[season];

  const next = { ...existing };
  if (Object.keys(nextKeyObj).filter(k => k !== 'name').length === 0) {
    delete next[key]; // remove entire fighter if nothing left
  } else {
    next[key] = nextKeyObj;
  }

  await ref.set({ records: next }, { merge:true });
  alert('Deleted manual entry.');
  if (_legacyActive) renderLegacyFighterList?.();
}


// ‚ö° Performance caches
let _combinedCache = null;
let _combinedCacheKey = '';
let _legacyActive = false;

// Render throttling
let _renderQueued = false;
function scheduleRenderAll() {
  if (_renderQueued) return;
  _renderQueued = true;
  requestAnimationFrame(() => {
    _renderQueued = false;
    renderAll?.();
    if (_legacyActive) renderLegacyFighterList?.();
  });
}


  const TITLES = [
  "UFL World Champion",
  "RBC Champion",
  "ABC Champion",
  "UFL Intercontinental Champion"
];

  
  const $ = id => document.getElementById(id);
  const escapeHtml = s => !s ? '' : String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  const formatDateShort = iso => {
    if(!iso) return 'N/A';
    try {
      const d = new Date(iso);
      const mm = (d.getMonth()+1).toString().padStart(2,'0');
      const dd = d.getDate().toString().padStart(2,'0');
      const yy = d.getFullYear().toString().slice(-2);
      return `${mm}/${dd}/${yy}`;
    } catch(e) { return 'N/A'; }
  };
  
  /* ===========================
     üîÅ FIRESTORE LISTENERS
     =========================== */
  
 /* ===========================
   üîÅ FIRESTORE LISTENERS
   =========================== */

db.collection('fighters').onSnapshot(snap => {
  fighters = snap.docs.map(d => ({ id: d.id, ...d.data() }));

  // normalize expected fields
  fighters.forEach(f => {
    f.wins = f.wins || 0;
    f.losses = f.losses || 0;
    f.draws = f.draws || 0;
    f.koWins = f.koWins || 0;
    f.retired = !!f.retired;
    f.platform = f.platform || '';
    // convenience totals (kept for rendering, recalculated in recomputeAllFighterStats when needed)
    f.totalFights = (f.wins + f.losses + f.draws) || 0;
  });

  // update any UI selects / lists that depend on fighters
  populateEditFightSelects?.();
  populateMatchmakingSelect?.();
  populateChampionTitleSelects?.();
  populateAdminFighters?.();

  // ‚úÖ throttle heavy rerenders
  scheduleRenderAll?.();

  // ‚úÖ ONLY rerender legacy list when the Legacy tab is open
  if (_legacyActive) renderLegacyFighterList?.();

  _fightersLoaded = true;
setLoading(!(_fightersLoaded && _fightsLoaded));



}, e => console.error('fighters listener error', e));


db.collection('fights').orderBy('date','desc').onSnapshot(snap => {
  // 1) Load ALL fights from Firestore (S2 + S3)
  allFights = snap.docs.map(d => ({ id: d.id, ...d.data() }));

  // 2) Normalize fields for ALL fights (safe)
  allFights.forEach(f => {
    f.platform = f.platform || '';
    f.method = f.method || '';
    f.caf = !!f.caf;

    f.fighter1Name = f.fighter1Name || (fighters.find(x => x.id === f.fighter1)?.name || '');
    f.fighter2Name = f.fighter2Name || (fighters.find(x => x.id === f.fighter2)?.name || '');
    f.winnerName = (f.winner === '0' || f.winner === 0)
      ? 'Draw'
      : (fighters.find(x => x.id === f.winner)?.name || '');
  });

  // 3) üîí Isolate Season 3 fights ONLY (and ignore legacy)
  //    - If season is missing, assume it's season 3 (your old fights)
  season3Fights = allFights.filter(f =>
    f.legacy !== true && (f.season === 3 || typeof f.season === 'undefined' || f.season === null)
  );

  // 4) ‚úÖ CRITICAL HOTFIX:
  //    Make the rest of the site (rankings/badges/points) see ONLY Season 3 fights.
  fights = season3Fights;

  // 5) Continue normal flow (now safe)
  populateEditFightSelects?.();
  recomputeTitleDefensesFromFights?.(season3Fights);

  // ‚úÖ throttle heavy rerenders
  scheduleRenderAll?.();

  // ‚úÖ If admin is unlocked, refresh the fights dropdown + list now that fights exist
  if (sessionStorage.getItem('isAdmin')) {
    populateAdminFightsDropdown?.();
    populateAdminFightsList?.();
  }

  // ‚úÖ If legacy tab open, refresh legacy list now that allFights changed
  if (_legacyActive) renderLegacyFighterList?.();

  _fightsLoaded = true;
setLoading(!(_fightersLoaded && _fightsLoaded));


}, e => console.error('fights listener error', e));


db.collection('settings').doc('legacyS1').onSnapshot(doc => {
  legacyS1Records = doc.exists ? (doc.data().records || {}) : {};
  // ‚úÖ if legacy tab open, refresh list to reflect s1 totals
  if (_legacyActive) renderLegacyFighterList?.();
}, e => console.warn('legacyS1 listener', e));


db.collection('settings').doc('champions').onSnapshot(doc => {
  champions = doc.exists ? doc.data() : {};

  // normalize fields we expect
  champions.uflWorld = champions.uflWorld || null;
  champions.uflWorldDefenses = champions.uflWorldDefenses || 0;
  champions.uflWorldLastDefense = champions.uflWorldLastDefense || '';

  champions.uflCAF = champions.uflCAF || null;
  champions.uflCAFDefenses = champions.uflCAFDefenses || 0;
  champions.uflCAFLastDefense = champions.uflCAFLastDefense || '';

  champions.uflPC = champions.uflPC || null;
  champions.uflPS5 = champions.uflPS5 || null;
  champions.uflXbox = champions.uflXbox || null;

  champions.rbcPC = champions.rbcPC || null;
  champions.rbcPS5 = champions.rbcPS5 || null;
  champions.rbcXbox = champions.rbcXbox || null;

  champions.youtubePlaylist = champions.youtubePlaylist || '';

  populateChampionTitleSelects?.();

  // ‚úÖ throttle heavy rerenders
  scheduleRenderAll?.();

}, e => console.warn('champions listener', e));


/* optional admin password stored in settings/admin */
db.collection('settings').doc('admin').get().then(doc => {
  if (doc.exists) window.ADMIN_PW = doc.data().password || null;
}).catch(() => { window.ADMIN_PW = null; });


db.collection('legacy_title_reigns').onSnapshot(snap => {
  legacyTitleReigns = snap.docs.map(d => ({ id: d.id, ...d.data() }));

  // ‚úÖ populate the Admin dropdown
  populateLegacyReignDropdown?.();

  // ‚úÖ refresh legacy list if open (titles/defenses counts may change)
  if (_legacyActive) renderLegacyFighterList?.();

}, e => console.warn('legacy_title_reigns listener', e));



  
  /* ===========================
     üß© COMBINE FIGHTER DATA (same names across platforms)
     =========================== */
  /*
    Returns an array of combined fighter objects:
    {
      name: 'PlayerName',
      ids: [ 'fighterDocIdPC','fighterDocIdPS5' ],
      wins, losses, draws, koWins,
      totalFights, retiredAll, isCAFAny,
      points (calculated later), lastFightDate, idMain (first id)
    }
  */
  /* ============================================================
   üîó Combine fighters across platforms by identical name
   ============================================================ */
   function buildCombinedMap() {
  if (!fighters || !Array.isArray(fighters) || fighters.length === 0) return [];

  // üîë Cache key changes only when fighter set changes
  const key = fighters.length + ':' + fighters.map(f => f.id).join('|');

  if (_combinedCache && _combinedCacheKey === key) {
    return _combinedCache;
  }

  const combinedMap = {};

  fighters.forEach(f => {
    if (!f || !f.name) return;

    const k = f.name.trim().toLowerCase();

    if (!combinedMap[k]) {
      combinedMap[k] = {
        name: f.name.trim(),
        ids: [],
        isCAFAny: false,
        wins: 0,
        losses: 0,
        draws: 0,
        koWins: 0,
        idMain: f.id,
        points: 0
      };
    }

    const cur = combinedMap[k];
    cur.ids.push(f.id);
    cur.isCAFAny = cur.isCAFAny || !!f.isCAF;
    cur.wins += parseInt(f.wins || 0, 10);
    cur.losses += parseInt(f.losses || 0, 10);
    cur.draws += parseInt(f.draws || 0, 10);
    cur.koWins += parseInt(f.koWins || 0, 10);
  });

  // ‚úÖ Store cache
  _combinedCache = Object.values(combinedMap).sort((a, b) =>
    a.name.localeCompare(b.name)
  );
  _combinedCacheKey = key;

  return _combinedCache;
}

// ‚úÖ Returns a Set of fighter IDs who have fought in Season 3
function getSeason3ActiveIdSet() {
  const set = new Set();

  (Array.isArray(season3Fights) ? season3Fights : []).forEach(f => {
    if (f?.fighter1) set.add(f.fighter1);
    if (f?.fighter2) set.add(f.fighter2);
  });

  return set;
}

  
  /* ===========================
     üî• STREAKS, WINS/LOSSES, BADGES
     =========================== */
  
  /* Compute hot/cold/neutral streak (for UI dot) */
  function computeStreakForCombined(ids, lookback=5){
    const relevant = fights.filter(f=> ids.includes(f.fighter1) || ids.includes(f.fighter2))
      .slice().sort((a,b)=> new Date(b.date) - new Date(a.date));
    if(!relevant.length) return 'neutral';
    let outcomes = [];
    for(let f of relevant){
      if(outcomes.length >= lookback) break;
      if(f.winner === '0' || f.winner === 0){ outcomes.push('D'); continue; }
      if(ids.includes(f.winner)) outcomes.push('W'); else outcomes.push('L');
    }
    if(outcomes.length === 0) return 'neutral';
    if(outcomes.slice(0,3).every(o=>o==='W')) return 'hot';
    if(outcomes.slice(0,3).every(o=>o==='L')) return 'cold';
    return 'neutral';
  }
  
  /* Count consecutive losses (most recent first) used for escalation penalty */
  function countConsecutiveLosses(ids){
    const relevant = fights.filter(f=> ids.includes(f.fighter1) || ids.includes(f.fighter2))
      .slice().sort((a,b)=> new Date(b.date) - new Date(a.date));
    let count = 0;
    for(const f of relevant){
      if(f.winner === '0' || f.winner === 0) break;
      if(f.winner && ids.includes(f.winner)) break; // win encountered -> stop
      if(f.winner && !ids.includes(f.winner)) count++;
    }
    return count;
  }
  
  /* Count consecutive wins (most recent first) */
  function countConsecutiveWins(ids){
    const relevant = fights.filter(f=> ids.includes(f.fighter1) || ids.includes(f.fighter2))
      .slice().sort((a,b)=> new Date(b.date) - new Date(a.date));
    let count = 0;
    for(const f of relevant){
      if(f.winner === '0' || f.winner === 0) break;
      if(f.winner && ids.includes(f.winner)) count++; else break;
    }
    return count;
  }
  
  /* Compute badges for a combined fighter (ordered by priority) */
  function computeBadgesForCombined(ids) {
  const combinedList = buildCombinedMap();
  const combined = combinedList.find(c => c.ids.some(id => ids.includes(id)));
  if (!combined) return [];

  const totalFights = (combined.wins + combined.losses + combined.draws) || 0;
  const winPct = totalFights > 0 ? (combined.wins / totalFights) : 0;
  const badges = [];


// üèÜ INTERCONTINENTAL CHAMPION BADGE
if (champions?.uflIntercontinental) {
  // Ensure IDs are compared as strings to avoid type issues
  const championId = String(champions.uflIntercontinental);
  const normalizedIds = ids.map(id => String(id));

  // Debug logs to see what‚Äôs happening
  console.log('Champion ID:', championId);
  console.log('IDs array:', normalizedIds);
  console.log('Includes check:', normalizedIds.includes(championId));

  if (normalizedIds.includes(championId)) {
    badges.push({
      key: 'Intercontinental Champion',
      icon: 'üèÜ',
      desc: `Intercontinental Champion ‚Äî ${champions.uflIntercontinentalDefenses || 0} defenses`
    });
    console.log('üèÜ Intercontinental Champion badge added for', championId);
  } else {
    console.warn('Champion ID not found in current fighter IDs.');
  }
} else {
  console.warn('No Intercontinental Champion is set in the champions object.');
}


  

  // üèõÔ∏è ICON BADGE ‚Äî 10+ fights and 80%+ win rate
  if (totalFights >= 10 && winPct >= 0.8) {
    badges.push({ key: 'Icon', icon: 'üèõÔ∏è', desc: 'Icon' });
  }

  // üî• WINNING STREAK
  const streakLen = countConsecutiveWins(ids);
  if (streakLen >= 1) {
    badges.push({ key: 'Winning Streak', icon: 'üî•', desc: `Current win streak: ${streakLen}` });
  }





  // ü•ä KO ARTIST ‚Äî 8+ fights and 4+ KO/TKO wins
  if (totalFights >= 8 && combined.koWins >= 4) {
    badges.push({ key: 'KO Artist', icon: 'ü•ä', desc: 'KO Artist' });
  }

 
// helper to safely convert Firestore timestamps or strings to Date
function safeDate(d) {
  if (!d) return null;
  if (d instanceof Date) return d;
  if (typeof d === 'object' && d.seconds) return new Date(d.seconds * 1000);
  return new Date(d);
}

  // ‚öôÔ∏è WORKHORSE ‚Äî 3+ fights in 10-day window
  let workhorse = false;
  const relevant = fights.filter(f => ids.includes(f.fighter1) || ids.includes(f.fighter2)).slice();
  for (let i = 0; i < relevant.length; i++) {
    const d1 = new Date(relevant[i].date);
    const windowStart = new Date(d1);
    windowStart.setDate(windowStart.getDate() - 10);
    const count = relevant.filter(f => {
      const d = new Date(f.date);
      return d >= windowStart && d <= d1;
    }).length;
    if (count >= 3) {
      workhorse = true;
      break;
    }
  }
  if (workhorse) {
    badges.push({ key: 'Workhorse', icon: '‚öôÔ∏è', desc: 'Workhorse ‚Äî 3+ fights in 10 days' });
  }


  

  // üåü RISING STAR ‚Äî between 4‚Äì7 fights and 80%+ win rate
if (totalFights >= 4 && totalFights < 8 && winPct >= 0.8) {
  badges.push({
    key: 'Rising Star',
    icon: 'üåü',
    desc: 'Rising Star ‚Äî Early Career Success'
  });
}

// üèÖ BONUS ‚Äî Fight of the Night only
let fotnCount = 0;

fights.forEach(ft => {
  const involved = ids.includes(ft.fighter1) || ids.includes(ft.fighter2);
  if (!involved) return;

  // handle different Firestore field names gracefully
  const rawBonus = (ft.bonus || ft.bonusType || ft.fightBonus || '').toString().toLowerCase();

  // match either explicit FOTN or flexible wording that includes 'fight'
  if (rawBonus === 'fotn' || /fight/i.test(rawBonus)) {
    fotnCount++;
  }
});

if (fotnCount > 0) {
  badges.push({
    key: 'Fight of the Night',
    icon: 'üí∞',
    desc: `Fight of the Night √ó${fotnCount}`
  });
}


// üåç GLOBAL BADGE ‚Äî Must have at least 3 wins vs EU and 3 wins vs NA fighters
¬†¬†try {
¬†¬†¬†¬†// count wins vs EU opponents
¬†¬†¬†¬†const winsVsEU = (Array.isArray(fights) ? fights : []).filter(ft => {
¬†¬†¬†¬†¬†¬†// did this fight have a winner that's one of the combined fighter ids?
¬†¬†¬†¬†¬†¬†if (!ft.winner || !ids.includes(ft.winner)) return false;

¬†¬†¬†¬†¬†¬†// was the combined fighter involved in this fight?
¬†¬†¬†¬†¬†¬†if (!(ids.includes(ft.fighter1) || ids.includes(ft.fighter2))) return false;

¬†¬†¬†¬†¬†¬†// determine opponent id (the other fighter in the fight)
¬†¬†¬†¬†¬†¬†const oppId = ids.includes(ft.fighter1) ? ft.fighter2 : ft.fighter1;
¬†¬†¬†¬†¬†¬†const opp = fighters.find(x => x.id === oppId);
¬†¬†¬†¬†¬†¬†return opp?.region === 'EU';
¬†¬†¬†¬†}).length;

¬†¬†¬†¬†// count wins vs NA opponents
¬†¬†¬†¬†const winsVsNA = (Array.isArray(fights) ? fights : []).filter(ft => {
¬†¬†¬†¬†¬†¬†if (!ft.winner || !ids.includes(ft.winner)) return false;
¬†¬†¬†¬†¬†¬†if (!(ids.includes(ft.fighter1) || ids.includes(ft.fighter2))) return false;
¬†¬†¬†¬†¬†¬†const oppId = ids.includes(ft.fighter1) ? ft.fighter2 : ft.fighter1;
¬†¬†¬†¬†¬†¬†const opp = fighters.find(x => x.id === oppId);
¬†¬†¬†¬†¬†¬†return opp?.region === 'NA';
¬†¬†¬†¬†}).length;

¬†¬†¬†¬†if (winsVsEU >= 3 && winsVsNA >= 3) {
¬†¬†¬†¬†¬†¬†badges.push({
¬†¬†¬†¬†¬†¬†¬†¬†key: 'Global',
¬†¬†¬†¬†¬†¬†¬†¬†icon: 'üåç',
¬†¬†¬†¬†¬†¬†¬†¬†desc: `Global ‚Äî ${winsVsEU} wins vs EU, ${winsVsNA} wins vs NA opponents`
¬†¬†¬†¬†¬†¬†});
¬†¬†¬†¬†}
¬†¬†} catch (err) {
¬†¬†¬†¬†console.error("GLOBAL badge check error:", err);
¬†¬†}


// ü§ú RIVALRY ‚Äî Faced the same opponent 3 or more times
try {
¬†¬†const matchCounts = {};

¬†¬†// Collect all fights the fighter participated in
¬†¬†(Array.isArray(fights) ? fights : []).forEach(ft => {
¬†¬†¬†¬†if (!(ids.includes(ft.fighter1) || ids.includes(ft.fighter2))) return;

¬†¬†¬†¬†const oppId = ids.includes(ft.fighter1) ? ft.fighter2 : ft.fighter1;
¬†¬†¬†¬†if (!oppId) return;
¬†¬†¬†¬†matchCounts[oppId] = (matchCounts[oppId] || 0) + 1;
¬†¬†});

¬†¬†// Find opponents fought 3+ times
¬†¬†const rivalIds = Object.keys(matchCounts).filter(id => matchCounts[id] >= 3);

¬†¬†if (rivalIds.length > 0) {
¬†¬†rivalIds.forEach(rid => {
¬†¬†¬†¬†const rival = fighters.find(x => x.id === rid);
¬†¬†¬†¬†const rivalName = rival?.name || "Unknown";
¬†¬†¬†¬†const fightsCount = matchCounts[rid];
¬†¬†¬†¬†badges.push({
¬†¬†¬†¬†¬†¬†key: `Rivalry-${rivalName}`,
¬†¬†¬†¬†¬†¬†icon: "ü§ú",
¬†¬†¬†¬†¬†¬†desc: `Rivalry ‚Äî Faced ${rivalName} ${fightsCount}√ó`
¬†¬†¬†¬†});
¬†¬†});
}
} catch (err) {
¬†¬†console.error("RIVALRY badge error:", err);
}


  // Order badges logically by importance
  const order = [
  'Champion',
  'Former Champion',
  'Icon',
  'Intercontinental Champion',
  'Winning Streak',
  'Global',
  'KO Artist',
  'Rivalry',
  'Workhorse',
  'Rising Star',
  'Fight of the Night'
];
badges.sort((a, b) => {
  // normalize keys so "Rivalry-John Doe" counts as "Rivalry"
  const keyA = a.key.startsWith('Rivalry') ? 'Rivalry' : a.key;
  const keyB = b.key.startsWith('Rivalry') ? 'Rivalry' : b.key;
  return order.indexOf(keyA) - order.indexOf(keyB);
});

  return badges;
}

  
  
  /* Recompute title defenses from fights (updates champions.*Defenses and last defense in memory only)
     Note: this function computes counts locally; saving to Firestore is done via the admin UI save function.
  */
  function recomputeTitleDefensesFromFights(fightList){
  const list = Array.isArray(fightList) ? fightList : fights; // fallback

  // reset counters
  let worldDefenses = 0, cafDefenses = 0;
  let worldLast = '', cafLast = '';

  list.forEach(f=>{
    if(!f.date) return;
    if(champions.uflWorld && (f.fighter1 === champions.uflWorld || f.fighter2 === champions.uflWorld)){
      if(f.winner === champions.uflWorld) {
        worldDefenses++;
        if(!worldLast || new Date(f.date) > new Date(worldLast)) worldLast = f.date;
      }
    }
    if(champions.uflCAF && (f.fighter1 === champions.uflCAF || f.fighter2 === champions.uflCAF)){
      if(f.winner === champions.uflCAF) {
        cafDefenses++;
        if(!cafLast || new Date(f.date) > new Date(cafLast)) cafLast = f.date;
      }
    }
  });

  champions.uflWorldDefenses = worldDefenses;
  champions.uflWorldLastDefense = worldLast || champions.uflWorldLastDefense || '';
  champions.uflCAFDefenses = cafDefenses;
  champions.uflCAFLastDefense = cafLast || champions.uflCAFLastDefense || '';
}

  
  /* Export some helpers for other parts */
  window.buildCombinedMap = buildCombinedMap;
  window.computeStreakForCombined = computeStreakForCombined;
  window.countConsecutiveWins = countConsecutiveWins;
  window.countConsecutiveLosses = countConsecutiveLosses;
  window.computeBadgesForCombined = computeBadgesForCombined;
  window.recomputeTitleDefensesFromFights = recomputeTitleDefensesFromFights;
  
  /* ===========================
   üèõÔ∏è BUILD LEGACY FIGHTER DATA
   =========================== */

   function renderLegacyFightListHTML(fightList, ids) {
  const sorted = (fightList || []).slice().sort((a,b) => new Date(b.date) - new Date(a.date));

  return `
    <div style="display:grid; gap:8px;">
      ${sorted.map(f => {
        const oppId = ids.includes(f.fighter1) ? f.fighter2 : f.fighter1;
        const oppName =
          (fighters.find(x => x.id === oppId)?.name) ||
          (ids.includes(f.fighter1) ? f.fighter2Name : f.fighter1Name) ||
          'Unknown';

        const result =
          (f.winner === '0' || f.winner === 0) ? 'Draw' :
          ids.includes(f.winner) ? 'Win' : 'Loss';

        return `
          <div class="frosted" style="padding:10px;border-radius:10px;">
            <div style="display:flex;justify-content:space-between;gap:10px;">
              <div><strong>${formatDateShort(f.date)}</strong> ‚Äî vs <strong>${escapeHtml(oppName)}</strong></div>
              <div style="font-weight:700;">${result}</div>
            </div>
            <div class="small-muted">${escapeHtml(f.method || '')} ${f.platform ? `‚Ä¢ ${escapeHtml(f.platform)}` : ''}</div>
          </div>
        `;
      }).join('')}
    </div>
  `;
}



function buildLegacyFighterData(combined) {
  const ids = combined.ids || [];

  // ---- Season 1 record (from settings/legacyS1)
  const nameKey = (combined.name || '').trim().toLowerCase();

// ‚úÖ Apply manual override if present for a season record
function applyManualOverride(seasonNum, fallback) {
  const man = legacyManualRecords?.[nameKey]?.[seasonNum];
  if (!man) return fallback;
  return {
    w: +man.w || 0,
    l: +man.l || 0,
    d: +man.d || 0
  };
}



// ---- Legacy champion history (titles & defenses)
// ---- Legacy champion history (titles & defenses)
// Supports either fighterKey OR fighterName in the reign docs
const reigns = (Array.isArray(legacyTitleReigns) ? legacyTitleReigns : []).filter(r => {
  const k = (r.fighterKey || '').toString().trim().toLowerCase();
  const n = (r.fighterName || '').toString().trim().toLowerCase();
  return k === nameKey || n === nameKey;
});

const championships = reigns.length;

// ‚úÖ Sort Championship Resume: by Season, then by wonDate
reigns.sort((a, b) => {
  const sa = +a.season || 999;
  const sb = +b.season || 999;
  if (sa !== sb) return sa - sb;

  const da = a.wonDate ? new Date(a.wonDate).getTime() : 0;
  const db = b.wonDate ? new Date(b.wonDate).getTime() : 0;
  return da - db;
});


// Flatten defenses for defense history modal
const defensesFlat = reigns.flatMap(r => {
  const defs = Array.isArray(r.defenses) ? r.defenses : [];
  return defs.map(d => ({
    date: d.date || '',
    opponent: d.opponent || '',
    event: d.event || (r.title ? `${r.title} Defense` : 'Title Defense'),
    method: d.method || ''
  }));
});

const defensesCount = defensesFlat.length;



  const s1Raw = legacyS1Records?.[nameKey] || null;
  const s1 = s1Raw
    ? { w: +s1Raw.w || 0, l: +s1Raw.l || 0, d: +s1Raw.d || 0 }
    : { w: 0, l: 0, d: 0 };

  const s1FightCount = (s1.w + s1.l + s1.d) || 0;

  const fmtRecord = (r) => `${r.w}‚Äì${r.l}${r.d ? `‚Äì${r.d}` : ''}`;

  // ---- Pull S2 + S3 fights from allFights
  const fighterFights = (Array.isArray(allFights) ? allFights : []).filter(f =>
    ids.includes(f.fighter1) || ids.includes(f.fighter2)
  );

  // Prefer explicit tagging; fall back to year split if needed
  const s2Fights = fighterFights.filter(f => f.legacy === true || f.season === 2 || new Date(f.date).getFullYear() === 2024);
  const s3Fights = fighterFights.filter(f => (f.legacy !== true) && (f.season === 3 || f.season == null) && new Date(f.date).getFullYear() !== 2024);

  function recordFor(fightsArr) {
  let w = 0, l = 0, d = 0;

  (fightsArr || []).forEach(f => {
    const raw = f?.winner;
    const winStr = (raw == null ? '' : String(raw)).trim().toLowerCase();

    const isDraw =
      raw === 0 ||
      raw === '0' ||
      winStr === 'draw' ||
      winStr === 'd' ||
      winStr === '' ||
      winStr === 'tie';

    if (isDraw) {
      d++;
      return;
    }

    if (ids.includes(raw)) w++;
    else l++;
  });

  return { w, l, d };
}


const s2 = recordFor(s2Fights);
const s3 = recordFor(s3Fights);

// ‚úÖ Final season records (manual override wins)
const s1Final = applyManualOverride(1, s1);
const s2Final = applyManualOverride(2, s2);
const s3Final = applyManualOverride(3, s3);

// ‚úÖ ALL-TIME now includes S1 too
const allW = s1Final.w + s2Final.w + s3Final.w;
const allL = s1Final.l + s2Final.l + s3Final.l;
const allD = s1Final.d + s2Final.d + s3Final.d;

// ‚úÖ ALL-TIME fights now includes S1 fight count too
const allFightCount = ((s1Final.w + s1Final.l + s1Final.d) + fighterFights.length);


  // ---- Season tab headers (record at top)
  const s2Header = `<div class="legacy-record-header" style="margin-bottom:8px;">
    <strong>Season 2 Record:</strong> ${fmtRecord(s2Final)} &nbsp;‚Ä¢&nbsp; <strong>Fights:</strong> ${s2Fights.length}
  </div>`;

  const s3Header = `<div class="legacy-record-header" style="margin-bottom:8px;">
    <strong>Season 3 Record:</strong> ${fmtRecord(s3Final)} &nbsp;‚Ä¢&nbsp; <strong>Fights:</strong> ${s3Fights.length}
  </div>`;

  const s1Header = `<div class="legacy-record-header" style="margin-bottom:8px;">
    <strong>Season 1 Record:</strong> ${fmtRecord(s1Final)} &nbsp;‚Ä¢&nbsp; <strong>Fights:</strong> ${s1FightCount}
  </div>`;

  // ---- CAREER tab plan: quick at-a-glance season breakdown + placeholder for accolades
  // ---- CAREER tab: show accolades (titles/defenses) + season breakdown
const reignLines = reigns.length
  ? reigns.map(r => {
      const season = r.season ? `S${r.season}` : '‚Äî';
      const title = escapeHtml(r.title || 'Title');
      const defCount = Array.isArray(r.defenses) ? r.defenses.length : (+r.defenses || 0);
      const won = r.wonDate ? formatDateShort(r.wonDate) : '';
      const lost = r.lostDate ? formatDateShort(r.lostDate) : 'Present';
      const dateLine = (won || r.lostDate) ? `<div class="small-muted" style="margin-top:2px;">${won || '‚Äî'} ‚Üí ${lost}</div>` : '';
      return `<li style="margin-bottom:6px;">
        <div><strong>${title}</strong> ‚Äî ${season} (${defCount} defenses)</div>
        ${dateLine}
      </li>`;
    }).join('')
  : `<li class="small-muted">No recorded championships.</li>`;

const careerHTML = `
  <div style="display:grid; gap:12px;">

    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
      <div class="frosted" style="padding:12px;">
        <div style="font-weight:800; color:var(--gold); margin-bottom:8px;">All-Time</div>
        <div style="font-size:16px; line-height:1.3;">
          <strong>${allW}‚Äì${allL}${allD ? `‚Äì${allD}` : ''}</strong>
          <span class="small-muted">(${allFightCount} fights)</span>
        </div>
        <div style="margin-top:6px;">
          <strong>Titles:</strong> ${championships} &nbsp;‚Ä¢&nbsp;
          <strong>Defenses:</strong> ${defensesCount}
        </div>
      </div>

      <div class="frosted" style="padding:12px;">
        <div style="font-weight:800; color:var(--gold); margin-bottom:8px;">Season Breakdown</div>
        <div><strong>S1:</strong> ${fmtRecord(s1Final)} (${(s1Final.w + s1Final.l + s1Final.d)})</div>
        <div><strong>S2:</strong> ${fmtRecord(s2Final)} (${s2Fights.length})</div>
        <div><strong>S3:</strong> ${fmtRecord(s3Final)} (${s3Fights.length})</div>
      </div>
    </div>

    <div class="frosted" style="padding:12px;">
      <div style="font-weight:800; color:var(--gold); margin-bottom:8px;">Championship Resume</div>
      <ul style="margin:0; padding-left:18px;">
        ${reignLines}
      </ul>
      <div class="small-muted" style="margin-top:8px;">
        Tip: Click the <strong>Titles</strong> box above to view reigns.
      </div>
    </div>

  </div>
`;


  return {
    name: combined.name,
    seasons: [1, 2, 3], // keep tabs consistent even if empty
    allTime: {
  record: `${allW}‚Äì${allL}${allD ? `‚Äì${allD}` : ''}`,
  fights: allFightCount,
  championships: championships,
  defenses: defensesCount
},
defenses: defensesFlat,
reigns: reigns,

    seasonData: {
      career: careerHTML,

      // S1 has record, but no fight list data
      s1: s1Header + (
        s1FightCount
          ? `<p><strong>Season 1 fight list not available</strong></p>`
          : `<p>No Season 1 record found.</p>`
      ),

      // S2/S3: record header + full list
      s2: (s2Fights.length ? (s2Header + renderLegacyFightListHTML(s2Fights, ids)) : (s2Header + `<p>No Season 2 fights found.</p>`)),
      s3: (s3Fights.length ? (s3Header + renderLegacyFightListHTML(s3Fights, ids)) : (s3Header + `<p>No Season 3 fights found.</p>`))
    }
  };
}


  /* ===========================
   üèõÔ∏è LEGACY MODAL (DEV ONLY)
   =========================== */

const mockLegacyFighter = {
  name: "Donny",
  seasons: [1, 2, 3],
  allTime: {
    record: "39‚Äì11‚Äì1",
    fights: 51,
    championships: 4,
    defenses: 6
  },

  defenses: [
    {
      date: "2024-08-12",
      opponent: "Ipro",
      event: "UFL Fight Night 18",
      method: "TKO (R5)"
    },
    {
      date: "2024-09-30",
      opponent: "Zedr",
      event: "UFL Championship Series",
      method: "UD"
    }
  ],

  seasonData: {
    career: `<p>One of the defining fighters in UFL history.</p>`,
    s1: `<p><strong>Record:</strong> 12‚Äì3‚Äì1<br/>Fight data unavailable.</p>`,
    s2: `<p><strong>Record:</strong> 18‚Äì6‚Äì0</p>`,
    s3: `<p><strong>Record:</strong> 9‚Äì2‚Äì0</p>`
  }
};

function openLegacyFighterModal(data) {
  $('legacy-name').textContent = data.name;
  $('legacy-sub').textContent = `Seasons: ${data.seasons.map(s=>'S'+s).join(' ‚Ä¢ ')}`;

  $('legacy-summary').innerHTML = `
  <div class="legacy-stat"><strong>${data.allTime.record}</strong><br/>All-Time</div>
  <div class="legacy-stat"><strong>${data.allTime.fights}</strong><br/>Fights</div>

  <div class="legacy-stat legacy-click" onclick="openTitleReignsModal(window._legacyReigns)">
    <strong>${data.allTime.championships}</strong><br/>Titles
  </div>

  <div class="legacy-stat legacy-click" onclick="openDefenseHistoryModal(window._legacyReigns)">
    <strong>${data.allTime.defenses}</strong><br/>Defenses
  </div>
`;


  window._legacyDefenses = data.defenses || [];

  window._legacyReigns = data.reigns || [];


  window._legacyTabs = data.seasonData;
  switchLegacyTab('career');
  $('legacy-modal-backdrop').classList.remove('hidden');
}

function closeLegacyFighterModal() {
  $('legacy-modal-backdrop').classList.add('hidden');
}

function switchLegacyTab(key) {
  document.querySelectorAll('.legacy-tab').forEach(t=>t.classList.remove('active'));
  document.querySelector(`.legacy-tab[onclick*="${key}"]`)?.classList.add('active');
  $('legacy-content').innerHTML = window._legacyTabs[key] || '';
}

/* ===========================
   üèÜ TITLE DEFENSE HISTORY
   =========================== */

   function openDefenseHistoryModal(reigns) {
  const container = $('defense-history-list');

  const list = Array.isArray(reigns) ? reigns.slice() : [];

  if (list.length === 0) {
    container.innerHTML = `<p>No recorded title defenses.</p>`;
    $('defense-modal-backdrop')?.classList.remove('hidden');
    return;
  }

  // ‚úÖ Sort reigns by Season, then wonDate
  list.sort((a, b) => {
    const sa = +a.season || 999;
    const sb = +b.season || 999;
    if (sa !== sb) return sa - sb;

    const da = a.wonDate ? new Date(a.wonDate).getTime() : 0;
    const db = b.wonDate ? new Date(b.wonDate).getTime() : 0;
    return da - db;
  });

  const html = list.map(r => {
    const title = escapeHtml(r.title || 'Title');
    const season = r.season ? `S${r.season}` : '‚Äî';

    const defs = Array.isArray(r.defenses) ? r.defenses.slice() : [];

    // sort defenses by date ascending
    defs.sort((a, b) => {
      const da = a.date ? new Date(a.date).getTime() : 0;
      const db = b.date ? new Date(b.date).getTime() : 0;
      return da - db;
    });

    if (defs.length === 0) {
      return `
        <div style="margin-bottom:14px;">
          <div style="font-weight:800; color:var(--gold); margin-bottom:6px;">
            ${title} ‚Äî ${season}
          </div>
          <div class="small-muted">No recorded defenses for this reign.</div>
        </div>
      `;
    }

    const rows = defs.map(d => `
      <div class="defense-row">
        <div>${formatDateShort(d.date)}</div>
        <div><strong>${escapeHtml(d.opponent || '')}</strong></div>
        <div>${escapeHtml(d.method || '')}</div>
      </div>
    `).join('');

    return `
      <div style="margin-bottom:14px;">
        <div style="font-weight:800; color:var(--gold); margin-bottom:6px;">
          ${title} ‚Äî ${season}
        </div>
        ${rows}
      </div>
    `;
  }).join('');

  container.innerHTML = html;
  $('defense-modal-backdrop')?.classList.remove('hidden');
}


function closeDefenseHistoryModal() {
  $('defense-modal-backdrop').classList.add('hidden');
}

 
function openTitleReignsModal(reigns) {
  const container = $('reigns-history-list');
  const list = (Array.isArray(reigns) ? reigns : []).slice().sort((a,b) => {
  const sa = +a.season || 999;
  const sb = +b.season || 999;
  if (sa !== sb) return sa - sb;
  const da = a.wonDate ? new Date(a.wonDate).getTime() : 0;
  const db = b.wonDate ? new Date(b.wonDate).getTime() : 0;
  return da - db;
});


  if (list.length === 0) {
    container.innerHTML = `<p>No recorded title reigns.</p>`;
  } else {
    container.innerHTML = list.map(r => {
      const defCount = Array.isArray(r.defenses) ? r.defenses.length : (+r.defenses || 0);
      const won = r.wonDate ? formatDateShort(r.wonDate) : '‚Äî';
      const lost = r.lostDate ? formatDateShort(r.lostDate) : 'Present';
      const season = r.season ? `S${r.season}` : '‚Äî';
      const title = escapeHtml(r.title || 'Title');
      return `
        <div class="defense-row" style="grid-template-columns: 120px 1fr 120px;">
          <div><strong>${season}</strong><br/><span class="small-muted">${won} ‚Üí ${lost}</span></div>
          <div><strong>${title}</strong><br/><span class="small-muted">${escapeHtml(r.fighterName || '')}</span></div>
          <div><strong>${defCount}</strong><br/><span class="small-muted">Defenses</span></div>
        </div>
      `;
    }).join('');
  }

  $('reigns-modal-backdrop')?.classList.remove('hidden');
}

function closeTitleReignsModal() {
  $('reigns-modal-backdrop')?.classList.add('hidden');
}



  </script>
  <!-- END Part 3 of 6 -->
<!-- START Part 4 of 6 -->
<script>
  /* ========================================================
     üßÆ RANKING ALGORITHM ‚Äî includes multipliers & decay
     ======================================================== */
  
  /*
   Scoring summary (you requested):
    - Win = +3 points
    - Loss = -2 points (escalates by ‚àí0.25 per consecutive loss)
    - Draw = +1 point
    - Title Capture = +2
    - Title Defense = +3
    - Championship fight multiplier = √ó1.5
    - Defense fight multiplier = √ó1.5
    - Contender multiplier = √ó1.25 (both top 10)
    - Recency bonus: √ó1.2 for fights within 10 days
    - Decay: lose 1% per day inactive after 10 days (max ‚àí20%)
  */
  
  // ---------------------------------------------
// üìÖ Utility: Days Between Dates
// ---------------------------------------------
function daysBetween(d1, d2) {
  try {
    const date1 = new Date(d1), date2 = new Date(d2);
    const diff = (date2 - date1) / (1000 * 60 * 60 * 24);
    return Math.floor(diff);
  } catch {
    return 999;
  }
}

// ---------------------------------------------
// üßÆ Main Ranking Calculator
// ---------------------------------------------
function calculateRankPoints(fighterIds, returnBreakdown = false, fightsList = null) {
  // --- Breakdown trackers (for Player Card)
  let breakdown = {
    base: 0,
    finish: 0, // ü•ä NEW: tracks KO/TKO bonuses
    opponent: 0,
    recency: 0,
    streak: 0,
    contender: 0,
    modifiers: 0
  };

  const now = new Date();
  const combined = (typeof buildCombinedMap === 'function') ? buildCombinedMap() : [];
  const fightsToUse = Array.isArray(fightsList) ? fightsList : fights;
const combinedFights = fightsToUse.filter(
  f => fighterIds.includes(f.fighter1) || fighterIds.includes(f.fighter2)
);


  if (combinedFights.length === 0) return returnBreakdown ? { ...breakdown, total: 0 } : 0;

  let points = 0;
  const consecutiveLosses = countConsecutiveLosses(fighterIds);
  const lossPenalty = 1.5 + (0.5 * Math.max(0, consecutiveLosses - 1));

  combinedFights.forEach(f => {


// üü° IC FIGHT OVERRIDE ‚Äî hard bypass
if (f.ic === true) {
  const isWin  = fighterIds.includes(f.winner);
  const isDraw = f.winner === '0' || f.winner === 0;
  const isLoss = !isWin && !isDraw;
  const isKO   = isWin && f.method && /ko|tko/i.test(f.method);

  if (isWin) {
    points += 1;
    breakdown.base += 1;

    // ü•ä IC KO/TKO bonus
    if (isKO) {
      points += 0.5;
      breakdown.finish += 0.5;
    }
  }

  if (isLoss) {
    points -= 1;
    breakdown.base -= 1;
  }

  // IC draw = 0 points

  return; // ‚õî skip ALL other ranking logic for this fight
}



    let base = 0;
    let bonus = 0;
    let multiplier = 1.0;

    const isWin = fighterIds.includes(f.winner);
    const isDraw = f.winner === '0' || f.winner === 0;
    const isLoss = !isWin && !isDraw;

    const f1Rank = getCurrentRank(f.fighter1);
    const f2Rank = getCurrentRank(f.fighter2);
    const selfRank = fighterIds.includes(f.fighter1) ? f1Rank : f2Rank;
    const oppRank = fighterIds.includes(f.fighter1) ? f2Rank : f1Rank;
    const rankDiff = Math.abs(selfRank - oppRank);

    // üèÜ Base system
    if (isWin) base += 2;
    if (isLoss) base -= lossPenalty;
    if (isDraw) base += 1;
    breakdown.base += base;

    // ü•ä KO/TKO Finish Bonus
if (isWin && f.method && /ko|tko/i.test(f.method)) {
  base += 1; // small bonus
  breakdown.finish += 1; // track in modifiers or create a separate "finishBonus" if you prefer
}


    // üß© Rank differential adjustment
   // if (isWin && selfRank > oppRank) {
    //  bonus += Math.min(rankDiff * 0.025, 0.5);
  //  } else if (isLoss && selfRank < oppRank) {
  //    bonus -= Math.min(rankDiff * 0.025, 0.5);
  //  }
  //  breakdown.modifiers += bonus;

// üß† Opponent Rank Impact (BONUS + BAD LOSS PENALTY)
const oppId = fighterIds.includes(f.fighter1) ? f.fighter2 : f.fighter1;
const oppCombined = combined.find(c => c.ids.includes(oppId));

let opponentRankImpact = 0;

if (oppCombined) {
  const totalFights =
    oppCombined.wins + oppCombined.losses + oppCombined.draws;

  // Require opponent to have a real r√©sum√©
  if (totalFights >= 6) {

    // ‚úÖ WIN BONUSES (who you beat)
    if (isWin) {
      if (oppRank <= 5) {
        opponentRankImpact = 3;
      } else if (oppRank <= 10) {
        opponentRankImpact = 2;
      } else if (oppRank <= 20) {
        opponentRankImpact = 1;
      }
    }

    // ‚ùå BAD LOSS PENALTIES (who you lost to)
    if (isLoss && selfRank <= 10 && oppRank >= 11 && oppRank <= 50) {
      if (selfRank <= 5) {
        opponentRankImpact = -2;
      } else {
        opponentRankImpact = -1;
      }
    }

    base += opponentRankImpact;
    breakdown.opponent += opponentRankImpact;
  }
}



    // üîù Contender Fight Bonus (Top 10 vs Top 10)
// üîù TURN BACK ON AFTER A FEW WEEKS
// if (f1Rank <= 10 || f2Rank <= 10) {
// multiplier *= 1.15;
// breakdown.contender += (base + bonus) * 0.15; // üÜï track separately




    // ‚è± Recency bump (within 10 days)
    const daysSince = daysBetween(f.date, now);
   
    
    if (daysSince <= 20) { // or 10 depending on your threshold
  multiplier *= 1.15;
  breakdown.recency += Math.max(0, (base + bonus) * 0.15);
 // record approximate bonus
}

    points += (base + bonus) * multiplier;
  });

  // üß® Win streak momentum bonus
  const streak = countConsecutiveWins(fighterIds);
  if (streak >= 3) {
    const streakBonus = Math.min((streak - 2) * 1, 5);
    points += streakBonus;
    breakdown.streak += streakBonus;
  }

  // üßÆ Inactivity decay
const lastFight = combinedFights.length
  ? new Date(Math.max(...combinedFights.map(f => new Date(f.date))))
  : null;

if (lastFight) {
  const inactiveDays = daysBetween(lastFight, now);
  if (inactiveDays > 20) {
    const decayRate = Math.min((inactiveDays - 20) * 0.005, 0.15);
    
    // üß† Track the decay penalty for Ranking Breakdown
    const decayLoss = points * decayRate;
    breakdown.modifiers -= decayLoss; // record decay as a negative impact

    points *= (1 - decayRate);
  }

  }

  // üëë (Optional) Champion bonuses ‚Äî currently disabled
  // const championKeys = [
  //   'uflWorld', 'uflCAF', 'uflPC', 'uflPS5', 'uflXbox',
  //   'rbcPC', 'rbcPS5', 'rbcXbox'
  // ];
  // for (const key of championKeys) {
  //   if (champions[key] && fighterIds.includes(champions[key])) {
  //     points += 10;
  //     breakdown.modifiers += 10;
  //   }
  // }

// ‚úÖ Final breakdown + return
breakdown.total = Math.round(points);

if (returnBreakdown) {
  return breakdown;
}

return breakdown.total;

}

function lastOpponents(fighterId, count = 5) {
  return fights
    .filter(f => f.fighter1 === fighterId || f.fighter2 === fighterId)
    .slice(0, count) // fights are already sorted DESC by Firestore listener
    .map(f => f.fighter1 === fighterId ? f.fighter2 : f.fighter1);
}

function suggestMatchups(fighterId) {
  const fighter = fighters.find(f => f.id === fighterId);
  if (!fighter) return [];

  const region = fighter.region;
  const fighterPoints = calculateRankPoints([fighterId]);

  // 1. Same region pool
  let pool = fighters.filter(f => f.region === region && f.id !== fighterId);

  // 2. Remove recent opponents
  const prev = lastOpponents(fighterId, 5);
  pool = pool.filter(f => !prev.includes(f.id));

  // 3. Score by point proximity
  const scored = pool.map(opp => {
    const oppPts = calculateRankPoints([opp.id]);
    return {
      id: opp.id,
      name: opp.name,
      region: opp.region,
      points: oppPts,
      diff: Math.abs(oppPts - fighterPoints)
    };
  });

  // 4. Sort by closest match
  scored.sort((a,b)=> a.diff - b.diff);

  return scored.slice(0, 3);
}

function runMatchmaking() {
  const select = document.getElementById("matchmaking-select");
  const resultsDiv = document.getElementById("matchmaking-results");

  const fighterId = select?.value;
  if (!fighterId) {
    resultsDiv.innerHTML = "<div>Select a fighter first.</div>";
    return;
  }

  const suggestions = suggestMatchups(fighterId);

  if (!suggestions || suggestions.length === 0) {
    resultsDiv.innerHTML = "<div>No valid matchups found.</div>";
    return;
  }

  resultsDiv.innerHTML = suggestions.map(s => `
    <div style="padding:6px 0; border-bottom:1px solid rgba(255,255,255,0.1);">
      <strong>${s.name}</strong>
      <div class="small-muted">Points: ${s.points}</div>
    </div>
  `).join("");
}

// ---------------------------------------------
// üìä Helpers & Ranking Render Pipeline
// ---------------------------------------------
function getCurrentRank(fid) {
  const all = buildCombinedMap();
  const ranked = all.sort((a, b) => b.points - a.points);
  const index = ranked.findIndex(r => r.ids.includes(fid));
  return index >= 0 ? index + 1 : 999;
}

function countCAFFights() {
  const totalCAF = fights.filter(f => f.caf === true).length;
  console.log(`ü•ã CAF fights detected: ${totalCAF}`);
}

function computeRankings(tab = window.currentTab || "world") {
  const combined = (typeof buildCombinedMap === 'function') ? buildCombinedMap() : [];

  // ‚úÖ Season 3 ACTIVE fighter ids = anyone who appears in current fights[]
  // (your listener already sets fights = season3Fights, so this is S3-only)
  const activeIds = new Set();
  (Array.isArray(fights) ? fights : []).forEach(ft => {
    if (ft?.fighter1) activeIds.add(ft.fighter1);
    if (ft?.fighter2) activeIds.add(ft.fighter2);
  });

  // ‚úÖ Keep ONLY fighters who actually fought in Season 3
  const season3Only = combined.filter(f =>
    Array.isArray(f.ids) && f.ids.some(id => activeIds.has(id))
  );

  // üö´ Exclude retired fighters and champions (on the Season-3-only pool)
  const activeOnly = season3Only.filter(f => {
    const main = fighters.find(x => x.id === f.idMain);
    let isChampion = false;

    // ü•á WORLD TAB ‚Äî exclude only UFL + CAF champs
    if (tab === "world") {
      isChampion =
        (champions?.uflWorld && f.ids.includes(champions.uflWorld)) ||
        (champions?.uflCAF && f.ids.includes(champions.uflCAF));
    }

    // üè¥‚Äç‚ò†Ô∏è RBC TAB ‚Äî exclude RBC champ
    if (tab === "rbc") {
      if (champions?.rbc && f.ids.includes(champions.rbc)) isChampion = true;
    }

    // ü¶Ö ABC TAB ‚Äî exclude ABC champ
    if (tab === "abc") {
      if (champions?.abc && f.ids.includes(champions.abc)) isChampion = true;
    }

    return !main?.retired && !isChampion;
  });

  // --- Helper: safely call calculateRankPoints with a filtered fights list ---
  function calcPointsWithFightsForIds(ids, fightsSubset) {
    const originalFights = (typeof window !== 'undefined') ? window.fights : fights;
    try {
      if (typeof window !== 'undefined') window.fights = fightsSubset;
      else fights = fightsSubset;
      return calculateRankPoints(ids);
    } catch (err) {
      console.error("calcPointsWithFightsForIds error:", err);
      return 0;
    } finally {
      if (typeof window !== 'undefined') window.fights = originalFights;
      else fights = originalFights;
    }
  }

  // --- 1) WORLD points using ONLY non-CAF fights ---
  activeOnly.forEach(f => {
    try {
      const relevantFights = (Array.isArray(fights) ? fights : []).filter(ft => {
        const involved = f.ids.includes(ft.fighter1) || f.ids.includes(ft.fighter2);
        if (!involved) return false;
        return !ft.caf; // exclude CAF fights from world points
      });

      const pts = calcPointsWithFightsForIds(f.ids, relevantFights);
      f.points = pts;
    } catch (err) {
      console.error("calculateRankPoints error for world:", err);
      f.points = 0;
    }
  });

  // sort descending
  activeOnly.sort((a, b) => b.points - a.points);

  // WORLD vs CAF split
  const world = activeOnly.filter(f => !f.isCAFAny);
  const caf   = activeOnly.filter(f => f.isCAFAny);

  // --- 2) RBC fights only (EU vs EU) ---
  const rbcFights = (Array.isArray(fights) ? fights : []).filter(ft => {
    const f1 = fighters.find(x => x.id === ft.fighter1);
    const f2 = fighters.find(x => x.id === ft.fighter2);
    return f1?.region === 'EU' && f2?.region === 'EU';
  });

  const rbcFightIds = [...new Set(rbcFights.flatMap(ft => [ft.fighter1, ft.fighter2]))];

  const rbc = activeOnly
    .filter(f => f.ids.some(id => rbcFightIds.includes(id)))
    .map(f => {
      const relevantIds = f.ids.filter(id => rbcFightIds.includes(id));
      const pts = calcPointsWithFightsForIds(relevantIds, rbcFights);
      return { ...f, points: pts };
    })
    .sort((a, b) => b.points - a.points)
    .slice(0, 15);

  // --- 3) ABC fights only (NA vs NA) ---
  const abcFights = (Array.isArray(fights) ? fights : []).filter(ft => {
    const f1 = fighters.find(x => x.id === ft.fighter1);
    const f2 = fighters.find(x => x.id === ft.fighter2);
    return f1?.region === 'NA' && f2?.region === 'NA';
  });

  const abcFightIds = [...new Set(abcFights.flatMap(ft => [ft.fighter1, ft.fighter2]))];

  const abc = activeOnly
    .filter(f => f.ids.some(id => abcFightIds.includes(id)))
    .map(f => {
      const relevantIds = f.ids.filter(id => abcFightIds.includes(id));
      const pts = calcPointsWithFightsForIds(relevantIds, abcFights);
      return { ...f, points: pts };
    })
    .sort((a, b) => b.points - a.points)
    .slice(0, 15);

  return { world, rbc, abc, caf };
}




function renderAll() {

  
  // compute rankings (may return { world, caf } or may compute internally)
  const rankingResult = computeRankings();
  // defensive unpack: allow computeRankings to return undefined / something else
  const world = rankingResult?.world || [];
  const caf   = rankingResult?.caf   || [];
  const rbc   = rankingResult?.rbc   || [];
  const abc   = rankingResult?.abc   || [];

  

  // DEBUG ‚Äî inspect what computeRankings returned
  console.log('üîé renderAll: computeRankings result:', {
    hasResult: !!rankingResult,
    worldLen: world.length,
    cafLen: caf.length,
    rankingResult
  });

  // üß† Cache the latest computed rankings for faster reloads
  try { localStorage.setItem('cachedRankings', JSON.stringify({ world, caf })); } catch(e){}

  // Render champion cards safely (only if the DOM node exists)
if (typeof renderChampionCard === 'function') {
  try {
    if ($('world-champion-card')) renderChampionCard('world', $('world-champion-card'));
    else console.warn('‚ö†Ô∏è world-champion-card not found in DOM');
  } catch (e) { console.error('renderChampionCard(world) error', e); }

  try {
    if ($('caf-champion-card')) renderChampionCard('caf', $('caf-champion-card'));
    else console.warn('‚ö†Ô∏è caf-champion-card not found in DOM');
  } catch (e) { console.error('renderChampionCard(caf) error', e); }

  try {
    if ($('rbc-champion-card')) renderChampionCard('rbc', $('rbc-champion-card'));
    else console.warn('‚ö†Ô∏è rbc-champion-card not found in DOM');
  } catch (e) { console.error('renderChampionCard(rbc) error', e); }

  try {
    if ($('abc-champion-card')) renderChampionCard('abc', $('abc-champion-card'));
    else console.warn('‚ö†Ô∏è abc-champion-card not found in DOM');
  } catch (e) { console.error('renderChampionCard(abc) error', e); }
} else {
  console.warn('‚ö†Ô∏è renderChampionCard function missing');
}

  // Render rankings (renderRankings expects array + container id)
  if (typeof renderRankings === 'function') {
    try {
      renderRankings(world, 'world-rankings');
    } catch (e) {
      console.error('renderRankings(world) error', e);
    }
    try {
      renderRankings(caf, 'caf-rankings');
    } catch (e) {
      console.error('renderRankings(caf) error', e);
    }
  } else {
    console.warn('‚ö†Ô∏è renderRankings function missing');
  }

  // Other UI sections
  try { if (typeof renderPlayers === 'function') renderPlayers(); } catch(e){ console.error('renderPlayers error', e); }
  try { if (typeof renderFights === 'function') renderFights(); } catch(e){ console.error('renderFights error', e); }




  // Ensure RBC and ABC tabs refresh too (safe calls)
try {
  if (typeof renderRBCTab === 'function') renderRBCTab();
} catch (e) {
  console.error('renderRBCTab error', e);
}

try {
  if (typeof renderABCTab === 'function') renderABCTab();
} catch (e) {
  console.error('renderABCTab error', e);
}


  // DEBUG ‚Äî quick DOM checks to help troubleshoot missing UI
  console.log('üîé DOM check:', {
    worldRankingsEl: !!document.getElementById('world-rankings'),
    cafRankingsEl:   !!document.getElementById('caf-rankings'),
    worldChampEl:    !!document.getElementById('world-champion-card'),
    cafChampEl:      !!document.getElementById('caf-champion-card'),
  });
}



// === CAF rankings renderer (always matches WORLD layout) ===


// === UFL CAF RANKINGS ‚Äî same style as WORLD and functional player cards ===


// === Robust CAF rankings renderer + delegated click handling ===


// === CAF Rankings renderer ‚Äî post-process names to attach real fighter IDs & handlers ===


// === CAF Tab Rendering (standalone version, identical layout to WORLD) ===


/* ================================================================
   ü•ã UFL CAF RANKINGS ‚Äî identical layout & player cards as WORLD
   ================================================================ */

   

function renderRBCTab() {
  const { rbc } = computeRankings("rbc");
  const container = document.getElementById("rbc-rankings");
  if (!container) {
    console.warn("‚ùå RBC container not found");
    return;
  }
  container.innerHTML = "";

  if (!rbc || rbc.length === 0) {
    container.innerHTML = `<div class="text-center text-[var(--muted)] py-4">RBC RANKINGS COMING SOON...</div>`;
    return;
  }

  rbc.forEach((f, i) => {
    const row = document.createElement("div");
    row.className = "fighter-row hover:bg-[rgba(255,215,0,0.05)] transition cursor-pointer";
    row.innerHTML = `
      <div class="rank-num">${i + 1}</div>
      <div class="fighter-name">${escapeHtml(f.name)}</div>
      <div class="fighter-record">${f.wins}-${f.losses}-${f.draws}</div>
    
    `;
    row.addEventListener("click", () => openFighterModal(f.idMain));

    container.appendChild(row);
  });
}

function renderABCTab() {
  const { abc } = computeRankings("abc");
  const container = document.getElementById("abc-rankings");
  if (!container) {
    console.warn("‚ùå ABC container not found");
    return;
  }
  container.innerHTML = "";

  if (!abc || abc.length === 0) {
    container.innerHTML = `<div class="text-center text-[var(--muted)] py-4">ABC RANKINGS COMING SOON...</div>`;
    return;
  }

  abc.forEach((f, i) => {
    const row = document.createElement("div");
    row.className = "fighter-row hover:bg-[rgba(255,215,0,0.05)] transition cursor-pointer";
    row.innerHTML = `
      <div class="rank-num">${i + 1}</div>
      <div class="fighter-name">${escapeHtml(f.name)}</div>
      <div class="fighter-record">${f.wins}-${f.losses}-${f.draws}</div>
      
    `;
    row.addEventListener("click", () => openFighterModal(f.idMain));

    container.appendChild(row);
  });
}



// === Unified Fighter Card Modal (WORLD + CAF compatible) ===


function showFighterCard(fid, mode = "world") {
  const fighter = fighters.find(f => f.id === fid || f.idMain === fid);

  if (!fighter) {
    alert("Fighter not found.");
    return;
  }

  // üß© Filter fights based on the mode
  let relevantFights = [];
  if (mode === "caf") {
    relevantFights = fights.filter(f => f.caf && (f.fighter1 === fid || f.fighter2 === fid));
  } else if (mode === "rbc") {
    relevantFights = fights.filter(f => {
      const f1 = fighters.find(x => x.id === f.fighter1);
      const f2 = fighters.find(x => x.id === f.fighter2);
      return f1?.region === "EU" && f2?.region === "EU" && (f.fighter1 === fid || f.fighter2 === fid);
    });
  } else if (mode === "abc") {
    relevantFights = fights.filter(f => {
      const f1 = fighters.find(x => x.id === f.fighter1);
      const f2 = fighters.find(x => x.id === f.fighter2);
      return f1?.region === "NA" && f2?.region === "NA" && (f.fighter1 === fid || f.fighter2 === fid);
    });
  } else {
    relevantFights = fights.filter(f => !f.caf && (f.fighter1 === fid || f.fighter2 === fid));
  }

  relevantFights.sort((a, b) => new Date(b.date) - new Date(a.date));

  const combined = buildCombinedMap().find(c => c.ids.includes(fid));
  const breakdown = calculateRankPoints(combined?.ids || [fid], true);
  const badges = computeBadgesForCombined(combined?.ids || [fid]);

  const modal = document.createElement("div");
  modal.className = "player-card-overlay";

  modal.innerHTML = `
  <div class="modal frosted" style="max-width:900px;">
    <button class="btn btn-danger" style="position:absolute;top:10px;right:14px;font-size:16px;"
      onclick="document.body.classList.remove('modal-open'); this.closest('.player-card-overlay').remove()">‚úñ</button>

    <div style="text-align:center;margin-bottom:12px;">
      <h2 style="font-family:Orbitron;font-size:28px;color:var(--gold);margin:0;">${fighter.name}</h2>
      <div class="small-muted">${
        mode === "caf" ? "UFL CAF Division" :
        mode === "rbc" ? "UFL RBC Division (EU vs EU)" :
        mode === "abc" ? "UFL ABC Division (NA vs NA)" :
        "UFL WORLD Division"
      }</div>
    </div>

    <div class="players-header" style="margin-bottom:10px;">
      <div class="players-columns">
        <div class="players-column-left">
          Record:
          <strong>${fighter.wins}-${fighter.losses}-${fighter.draws}</strong>
          (${fighter.koWins} KO)
        </div>
      </div>
    </div>

    <div style="text-align:center;margin-bottom:10px;">
      ${badges.map(b => `<span class="badge" title="${b.desc}">${b.icon}</span>`).join("") 
        || "<span class='text-[var(--muted)] text-sm'>No badges yet</span>"}
    </div>

    <div class="breakdown">
      <div><strong>Base:</strong> ${breakdown.base.toFixed(1)}</div>
      <div><strong>Finish Bonus:</strong> ${breakdown.finish.toFixed(1)}</div>
      <div><strong>Opponent:</strong> ${breakdown.opponent.toFixed(1)}</div>
      <div><strong>Recency:</strong> ${breakdown.recency.toFixed(1)}</div>
      <div><strong>Streak:</strong> ${breakdown.streak.toFixed(1)}</div>
      <div><strong>Modifiers:</strong> ${breakdown.modifiers.toFixed(1)}</div>
      <div class="mt-2 text-lg"><strong>Total:</strong> ${breakdown.total}</div>
    </div>

    <h3 style="color:var(--gold);font-family:Orbitron;margin-top:14px;">Fight History</h3>
    <div id="fight-history" style="max-height:400px;overflow-y:auto;">
      ${
        relevantFights.length === 0
          ? `<div class="text-center text-[var(--muted)] py-4">No fights recorded.</div>`
          : relevantFights.map(f => {
              const f1 = fighters.find(x => x.id === f.fighter1)?.name || "Unknown";
              const f2 = fighters.find(x => x.id === f.fighter2)?.name || "Unknown";
              const isDraw = f.winner === "0" || f.winner === "draw";
              const winnerName = isDraw ? "Draw" : fighters.find(x => x.id === f.winner)?.name || "Unknown";
              const method = f.method || "‚Äî";
              const date = formatDateShort(f.date);
              const result = isDraw ? "Draw" : `${winnerName} won`;
              return `
                <div class="fights-row">
                  <div>${date}</div>
                  <div>${f1} vs ${f2}</div>
                  <div>${method}</div>
                  <div>${result}</div>
                </div>`;
            }).join("")
      }
    </div>

    <!-- üîÑ COMPARE BUTTON -->
    <div style="margin-top:20px; text-align:center;">
      <button class="btn btn-primary"
              onclick="openCompareModal('${fighter.id}')"
              style="width:100%; padding:10px; font-size:16px;">
        üîÑ Compare With Another Fighter
      </button>
    </div>

  </div> <!-- modal -->
  </div> <!-- overlay -->
  `;

  document.body.classList.add("modal-open");
  document.body.appendChild(modal);
}





// ‚úÖ Recompute all fighter stats including CAF
async function recomputeAllFighterStats() {
  const stats = {};
  fighters.forEach(f => {
    stats[f.id] = { 
      wins: 0, losses: 0, draws: 0, koWins: 0,
      cafWins: 0, cafLosses: 0, cafDraws: 0, cafKoWins: 0 // ‚úÖ CAF record fields
    };
  });

  fights.forEach(ft => {
    const f1 = ft.fighter1, f2 = ft.fighter2;
    if (!f1 || !f2) return;

    const winner = (ft.winner === '0' || ft.winner === 0 || ft.winner === 'draw') ? 'DRAW' : ft.winner;
    const isCAF = !!ft.caf; // ‚úÖ identify CAF fight

    if (winner === 'DRAW') {
      if (stats[f1]) isCAF ? stats[f1].cafDraws++ : stats[f1].draws++;
      if (stats[f2]) isCAF ? stats[f2].cafDraws++ : stats[f2].draws++;
    } else {
      if (stats[winner]) {
        if (isCAF) stats[winner].cafWins++;
        else stats[winner].wins++;
      }
      const loser = (winner === f1) ? f2 : f1;
      if (stats[loser]) {
        if (isCAF) stats[loser].cafLosses++;
        else stats[loser].losses++;
      }

      if ((ft.method || '').toLowerCase().includes('KO/TKO')) {
        if (stats[winner]) {
          if (isCAF) stats[winner].cafKoWins++;
          else stats[winner].koWins++;
        }
      }
    }
  });

  // ‚úÖ batch update Firestore with both normal and CAF stats
  const batch = db.batch();
  Object.keys(stats).forEach(fid => {
    const ref = db.collection('fighters').doc(fid);
    batch.set(ref, stats[fid], { merge: true });
  });

  try {
    await batch.commit();
    console.log('‚úÖ Recomputed fighter stats (including CAF).');
  } catch (e) {
    console.error('üî• recomputeAllFighterStats error', e);
  }
}


function refreshRankings() {
  renderAll();
  alert('Rankings refreshed!');
}


/* ===========================
   üèõÔ∏è LEGACY FIGHTER LIST
   =========================== */

   function renderLegacyFighterList() {
  const container = document.getElementById('legacy-fighter-list');
  if (!container) return;

  const q = (document.getElementById('legacy-search')?.value || '').trim().toLowerCase();

  // ‚úÖ Alphabetical sort
// ‚úÖ Alphabetical base list (Season 3 combined fighters)
const base = (buildCombinedMap?.() || []).slice();

// ‚úÖ Add Season 1-only fighters from legacyS1Records (settings/legacyS1)
const s1Extras = Object.values(legacyS1Records || {}).map(r => ({
  name: (r.name || r.playerName || '').trim(),
  ids: [],         // no S3 fighter ids
  wins: 0, losses: 0, draws: 0, koWins: 0,
  idMain: null,
  points: 0
})).filter(x => x.name);

// ‚úÖ Add manual-entry fighters (Season 1-only, etc.)
const manualNames = (typeof getLegacyManualNames === 'function') ? (getLegacyManualNames() || []) : [];
const manualExtras = manualNames.map(n => ({
  name: (n || '').trim(),
  ids: [],         // no S3 fighter ids
  wins: 0, losses: 0, draws: 0, koWins: 0,
  idMain: null,
  points: 0
})).filter(x => x.name);

// ‚úÖ Merge base + s1Extras + manualExtras uniquely by nameKey
const combined = [...base, ...s1Extras, ...manualExtras]
  .reduce((acc, cur) => {
    const k = (cur.name || '').trim().toLowerCase();
    if (!k) return acc;
    if (!acc.map[k]) { acc.map[k] = cur; acc.list.push(cur); }
    return acc;
  }, { map: {}, list: [] }).list
  .sort((a,b)=> (a.name || '').localeCompare((b.name || ''), undefined, { sensitivity:'base' }));



  combined.forEach(f => {
    const nameLower = (f.name || '').toLowerCase();
    if (q && !nameLower.includes(q)) return;

    // Build legacy data to get all-time record
    const data = buildLegacyFighterData(f);

    const row = document.createElement('div');
    row.className = 'legacy-fighter-row';
    row.innerHTML = `
      <div class="legacy-name">${data.name}</div>
      <div class="legacy-meta">
        <strong>${data.allTime.record}</strong>
      </div>
    `;

    row.onclick = () => openLegacyFighterModal(data);

    container.appendChild(row);
  });
}





  </script>
  <!-- END Part 4 of 6 -->
<!-- START Part 5 of 6 -->
<script>
  /* ============================================================
     üèÜ  RENDERING ‚Äî Champion cards, Rankings, Fighters, Modals
     ============================================================ */
  
  /* Floating Champion Card with gold crown icon */
function renderChampionCard(type, container) {
  let field, title, defenses, lastDefense;

  switch (type) {
    case 'world':
      field = 'uflWorld';
      title = 'UFL WORLD CHAMPION';
      defenses = champions.uflWorldDefenses || 0;
      lastDefense = champions.uflWorldLastDefense;
      break;
    case 'rbc':
      field = 'rbc';
      title = 'RBC CHAMPION';
      defenses = champions.rbcDefenses || 0;
      lastDefense = champions.rbcLastDefense;
      break;
    case 'abc':
      field = 'abc';
      title = 'ABC CHAMPION';
      defenses = champions.abcDefenses || 0;
      lastDefense = champions.abcLastDefense;
      break;
    case 'caf':
      field = 'uflCAF';
      title = 'UFL CAF CHAMPION';
      defenses = champions.uflCAFDefenses || 0;
      lastDefense = champions.uflCAFLastDefense;
      break;
    default:
      return;
  }

  const champId = champions?.[field];
  const champData = fighters.find(f => f.id === champId);

  // üßÆ Get combined record across platforms
  let recordText = '';
  if (champData) {
    const combinedList = buildCombinedMap();
    const combinedEntry = combinedList.find(c => c.ids.includes(champData.id));
    const wins = combinedEntry ? combinedEntry.wins : champData.wins || 0;
    const losses = combinedEntry ? combinedEntry.losses : champData.losses || 0;
    const draws = combinedEntry ? combinedEntry.draws : champData.draws || 0;
    recordText = `${wins}-${losses}-${draws}`;
  }

  // ü™Ñ Render the champion card
  container.innerHTML = `
    <div class="champion-card floating-card">
      <div class="champion-header">
        <i class="fas fa-crown champion-crown"></i>
        <h2 class="champion-title">${title}</h2>
      </div>
      <div class="champion-body">
        ${
          champData
            ? `<h3 class="champion-name clickable" onclick="openFighterModal('${champData.id}')">${escapeHtml(champData.name)}</h3>`
            : `<h3 class="champion-name vacant">VACANT</h3>`
        }
        ${
          champData
            ? `<p class="champion-record">Record: <strong>${recordText}</strong></p>`
            : ''
        }
        <p class="champion-details">
          ${defenses > 0 ? `<span class="champion-defenses">${defenses} Defense${defenses > 1 ? 's' : ''}</span>` : ''}
        </p>
        ${lastDefense ? `<p class="champion-last-defense">Last Defense: ${formatDateShort(lastDefense)}</p>` : ''}
      </div>
    </div>`;
}

  
/* Rank list with numbers & small platform-champ icons */
function renderRankings(list, containerId) {
  const container = $(containerId);
  if (!container) return;
  container.innerHTML = '';

  // try to locate a search input that follows the naming convention: "<containerId-without-suffix>-search"
  // e.g. "world-rankings" -> "world-search"
  const searchInputId = containerId.replace('-rankings', '-search');
  const query = (document.getElementById(searchInputId)?.value || '').toLowerCase();

  // apply optional query filter (if query present)
  const listToRender = query
    ? list.filter(f => (f.name || '').toLowerCase().includes(query))
    : list;

  // render the filtered list (keeps existing numbering)
  listToRender.forEach((f, i) => {
    const rankNum = i + 1;
    const champIcons = getChampionIcons(f);
    const points = f.points ?? 0; // safe fallback

    container.insertAdjacentHTML('beforeend', `
      <div class="fighter-row" onclick="openFighterModal('${f.idMain}')">
        <div class="rank-num">#${rankNum}</div>
        <div class="fighter-name">${escapeHtml(f.name)} ${champIcons}</div>
        <div class="fighter-record">${f.wins}-${f.losses}-${f.draws}</div>
      </div>
    `);
  });

  // show empty message if nothing matched
  if (listToRender.length === 0) {
    container.innerHTML = `<div class="text-center text-[var(--muted)] py-4">No fighters match your search.</div>`;
  }
}

  
  /* Small trophy icons for platform champs */
  function normalizeId(id) {
  return String(id).split(':').pop();
}

function getChampionIcons(f) {
  const icons = [];
  const champMap = {
    uflWorld: 'UFL World',
    uflIntercontinental: 'UFL Intercontinental',
    rbc: 'RBC',
    abc: 'ABC',
    uflCAF: 'UFL CAF'
  };

  const fighterIds = [
    ...(f.ids || []).map(normalizeId),
    ...(f.id ? [normalizeId(f.id)] : [])
  ];

  for (const [field, label] of Object.entries(champMap)) {
    if (
      champions[field] &&
      fighterIds.includes(normalizeId(champions[field]))
    ) {
      icons.push(
        `<i class="fas fa-trophy champ-icon" title="${label} Champion"></i>`
      );
    }
  }

  return icons.join(' ');
}


  
  /* Fights tab render */
  function renderFights() {
    const query = ($('fights-search')?.value || '').toLowerCase();
    const list = fights.slice().sort((a,b)=> new Date(b.date)-new Date(a.date));
    const container = $('fights-list');
    if (!container) return;
    container.innerHTML = '';
    list.forEach(f=>{
      const f1 = fighters.find(x=>x.id===f.fighter1)?.name || 'Unknown';
      const f2 = fighters.find(x=>x.id===f.fighter2)?.name || 'Unknown';
      const fightStr = `${f1} vs ${f2}`;
      if (query && !fightStr.toLowerCase().includes(query)) return;
      const winner = (f.winner==='0'||f.winner===0)?'Draw':(fighters.find(x=>x.id===f.winner)?.name || '');
      container.insertAdjacentHTML('beforeend',`
  <div class="fights-row">
    <div>${formatDateShort(f.date)}</div>
    <div>${escapeHtml(fightStr)}</div>
    <div>${escapeHtml(f.method||'')}</div>
    <div>${escapeHtml(winner)}</div>
  </div>`);

    });
  }
  
  /* Players tab render ‚Äî fixed for proper point totals */
function renderPlayers() {
  const query = ($('players-search')?.value || '').toLowerCase();
  const combinedList = buildCombinedMap();

  // Recalculate total points for each combined fighter
  combinedList.forEach(f => {
    f.points = calculateRankPoints(f.ids);
  });


  function runMatchmaking() {
  const fId = $("matchmaking-select").value;
  const resultsDiv = $("matchmaking-results");

  const matches = suggestMatchups(fId);
  if (!matches.length) {
    resultsDiv.innerHTML = `<div class="small-muted">No valid opponents found.</div>`;
    return;
  }

  resultsDiv.innerHTML = matches.map(m => `
    <div class="frosted" style="padding:10px;margin-top:8px;">
      <div><strong>${escapeHtml(m.name)}</strong> (${m.region})</div>
      <div class="small-muted">Points: ${m.points}</div>
      <div class="small-muted">Difference: ${m.diff}</div>
    </div>
  `).join("");
}


  // Sort by total points descending
  
// üßÆ Sort by points, then head-to-head, then recent activity
// üßÆ Sort by points, then head-to-head, then recent activity
const list = combinedList.sort((a, b) => {
  if (b.points !== a.points) return b.points - a.points;



  // üïì Recent activity tiebreaker
  const getLastFightDate = fighter => {
    const times = fights
      .filter(ft => fighter.ids.includes(ft.fighter1) || fighter.ids.includes(ft.fighter2))
      .map(ft => new Date(ft.date).getTime())
      .filter(Boolean); // remove invalid dates
    return times.length ? Math.max(...times) : 0;
  };


    // ü•ä Head-to-head tiebreaker
    const h2h = fights.filter(
    ft =>
      (a.ids.includes(ft.fighter1) && b.ids.includes(ft.fighter2)) ||
      (a.ids.includes(ft.fighter2) && b.ids.includes(ft.fighter1))
  );

  if (h2h.length) {
    const aWins = h2h.filter(ft => a.ids.includes(ft.winner)).length;
    const bWins = h2h.filter(ft => b.ids.includes(ft.winner)).length;
    if (aWins !== bWins) return bWins - aWins;
  }

  const aLast = getLastFightDate(a);
  const bLast = getLastFightDate(b);
  if (aLast && bLast && aLast !== bLast) return bLast - aLast;

  return 0;
});


  const container = $('players-list');
  if (!container) return;

  // Add column headers
  container.innerHTML = `
    <div class="player-header-row">
      <span class="player-header-left"></span>
      <span class="player-header-right"></span>
    </div>
  `;

  // Loop through players and render rows
  list.forEach(f => {
    if (query && !f.name.toLowerCase().includes(query)) return;

    const streak = computeStreakForCombined(f.ids);
    const streakClass = streak === 'hot' ? 'hot' : streak === 'cold' ? 'cold' : 'neutral';
    const streakSymbol = streak === 'hot' ? '‚ñ≤' : streak === 'cold' ? '‚ñº' : '‚Äì';

    container.insertAdjacentHTML(
      'beforeend',
      `
        <div class="player-row" onclick="openFighterModal('${f.idMain}')">
          <span class="players-column-left">
            <span class="streak ${streakClass}">${streakSymbol}</span>
            ${escapeHtml(f.name)}
          </span>
          
        </div>
      `
    );
  });
}

  
  /* Fighter modal (clickable name) with opponents list and badges ‚Äî SAFE VERSION */
function openFighterModal(id) {
  const modal = $('fighter-modal');
  const content = $('fighter-modal-content');

// Enable scrollable player card for overflow content
content.style.maxHeight = '80vh'; // limits height to 80% of screen
content.style.overflowY = 'auto';
content.style.scrollBehavior = 'smooth';


  // Ensure data exists
  if (!fighters || !Array.isArray(fighters) || fighters.length === 0) {
    alert('Fighter data not loaded yet.');
    return;
  }
  if (!fights || !Array.isArray(fights)) fights = [];

  // Find fighter by ID
  const f = fighters.find(x => x.id === id);
  if (!f) { alert('Fighter not found'); return; }

  // Find combined entry (across platforms)
  const combinedList = buildCombinedMap();
  const combinedEntry = combinedList.find(c => c.ids.includes(id));

  // Gather totals (fallback to fighter record if combined unavailable)
  const totalWins    = combinedEntry ? combinedEntry.wins    : parseInt(f.wins    || 0);
  const totalLosses  = combinedEntry ? combinedEntry.losses  : parseInt(f.losses  || 0);
  const totalDraws   = combinedEntry ? combinedEntry.draws   : parseInt(f.draws   || 0);
  const totalKOs     = combinedEntry ? combinedEntry.koWins  : parseInt(f.koWins  || 0);
  const allIDs       = combinedEntry ? combinedEntry.ids     : [f.id];

  // Compute badges using combined IDs
  const badges = computeBadgesForCombined(allIDs);

  // Build fights list safely
  let fightsList = '';
  try {
    fightsList = fights
      .filter(ft => allIDs.includes(ft.fighter1) || allIDs.includes(ft.fighter2))
      .sort((a,b) => new Date(b.date) - new Date(a.date))
      .map(ft => {
        const isDraw = (ft.winner === '0' || ft.winner === 0);
        const isWin  = allIDs.includes(ft.winner);
        const oppId  = allIDs.includes(ft.fighter1) ? ft.fighter2 : ft.fighter1;
        const oppName = fighters.find(x => x.id === oppId)?.name || 'Unknown';
        const result = isDraw ? 'Draw' : isWin ? 'Win' : 'Loss';
        return `<div class="fight-history-row">${formatDateShort(ft.date)} ‚Äî ${result} vs ${escapeHtml(oppName)} <span class="small-muted">(${escapeHtml(ft.method||'')})</span></div>`;
      })
      .join('');
  } catch (e) {
    console.error('Fight list render error:', e);
    fightsList = '<p>Unable to load fight history.</p>';
  }

  // Render modal content
  content.innerHTML = `

  
  
    <div class="fighter-modal-header">
    <div style="display:flex;justify-content:space-between;align-items:center;">

      
      <h2 style="font-size: 28px; font-weight: 700; color: var(--gold); margin-bottom: 4px;">
  ${escapeHtml(f.name)}
</h2>

  
  <button onclick="closeFighterModal()" style="background:none;border:0;color:#fff;font-size:18px;cursor:pointer;">‚úñ</button>
</div>

<div class="player-record-top" style="
  font-size:22px;
  font-weight:800;
  color: var(--gold);
  margin: 8px 0 14px;
">
  ${totalWins}‚Äì${totalLosses}${totalDraws ? `‚Äì${totalDraws}` : ''}
</div>


      <div class="fighter-badges">
        ${badges.map(b => `<span class="badge" onclick="showBadgeDesc('${b.desc}')">${b.icon}</span>`).join('')}

      </div>
    </div>
    <div class="fighter-modal-body">
   

<!-- RANKING BREAKDOWN SECTION -->
<div class="ranking-breakdown-section" style="margin:12px 0;padding:10px;border:1px solid rgba(255,215,0,0.25);border-radius:8px;background:rgba(0,0,0,0.3);">
  <h3 style="color:var(--gold);margin-bottom:6px;">Ranking Breakdown</h3>
  <div id="ranking-breakdown-content" style="font-size:14px;color:#ccc;">
    Loading...
  </div>
</div>

<div class="fight-history">
        <h3>Past Fights</h3>
        ${fightsList || '<p>No fights yet.</p>'}
      </div>
    </div>`;
    // --- Live Ranking Breakdown injection ---
try {
  if (typeof calculateRankPoints === 'function' && allIDs?.length) {
    const breakdown = calculateRankPoints(allIDs, true);
    const bdEl = document.getElementById('ranking-breakdown-content');
    if (bdEl && breakdown) {
      bdEl.innerHTML = `
        <div><strong>Base Points:</strong> ${breakdown.base.toFixed(1)}</div>
        <div><strong>Finish Bonus:</strong> ${breakdown.finish.toFixed(1)}</div>

        <div><strong>Opponent Quality:</strong> ${breakdown.opponent.toFixed(1)}</div>
        <div><strong>Recency Bonus:</strong> ${breakdown.recency.toFixed(1)}</div>
        <div><strong>Streak Bonus:</strong> ${breakdown.streak.toFixed(1)}</div>
        <div><strong>Contender Bonus:</strong> ${breakdown.contender.toFixed(1)}</div>
        <div><strong>Modifiers:</strong> ${breakdown.modifiers.toFixed(1)}</div>
        <hr style="margin:6px 0;border-color:rgba(255,215,0,0.25);">
        <div><strong>Total:</strong> ${breakdown.total.toFixed(1)}</div>
      `;
    }
  }
} catch (e) {
  console.warn('Ranking Breakdown failed for', f.name, e);
  const bdEl = document.getElementById('ranking-breakdown-content');
  if (bdEl) bdEl.innerHTML = `<div style="color:#999;">No ranking data available.</div>`;
}


    // ‚ú® Gold border & pop-in animation for the player card
content.style.border = '1px solid gold';
content.style.boxShadow = '0 0 8px rgba(255, 215, 0, 0.4)';
content.style.borderRadius = '10px';
content.style.background = 'rgba(0, 0, 0, 0.92)';
content.style.transition = 'transform 0.25s ease-out, opacity 0.25s ease-out';
content.style.transform = 'scale(0.9)';
content.style.opacity = '0';
setTimeout(() => {
  content.style.transform = 'scale(1)';
  content.style.opacity = '1';
}, 10);

  modal.classList.remove('hidden');
}

function showBadgeDesc(desc) { const existing = document.getElementById('badge-desc-popup'); if (existing) existing.remove(); const popup = document.createElement('div'); popup.id = 'badge-desc-popup'; popup.textContent = desc; popup.style.position = 'fixed'; popup.style.bottom = '20px'; popup.style.left = '50%'; popup.style.transform = 'translateX(-50%)'; popup.style.background = 'rgba(0,0,0,0.85)'; popup.style.color = '#ffd700'; popup.style.padding = '10px 16px'; popup.style.borderRadius = '10px'; popup.style.fontSize = '14px'; popup.style.border = '1px solid rgba(255,215,0,0.3)'; popup.style.zIndex = '9999'; popup.style.maxWidth = '80%'; popup.style.textAlign = 'center'; popup.style.boxShadow = '0 0 8px rgba(255,215,0,0.4)'; document.body.appendChild(popup); setTimeout(() => popup.remove(), 3000); }

  function closeFighterModal(){ $('fighter-modal').classList.add('hidden'); }
  
  /* Simple tab switcher (ensures one visible at all times) */
  function switchTab(tab) {
  const tabs = ['home', 'world', 'rbc', 'abc', 'fights', 'legacy', 'admin'];

  // ‚úÖ track whether legacy is active (for perf)
  _legacyActive = (tab === 'legacy');

  tabs.forEach(t => {
    const el = document.getElementById(t + '-tab');
    const btn = document.getElementById('btn-' + t);

    if (el) el.classList.toggle('hidden', t !== tab);
    if (btn) btn.classList.toggle('tab-active', t === tab);
  });

  // üîß Render only the active tab‚Äôs content
  switch (tab) {
 
    case 'fights':
      renderFights?.();
      break;
    case 'admin':
      renderAdmin?.();
      break;
    case 'legacy':
      // ‚úÖ only render legacy list when you open the legacy tab
      renderLegacyFighterList?.();
      break;
    default:
      // ‚úÖ throttle heavy rerenders
      scheduleRenderAll?.();
      break;
  }
}

document.addEventListener('DOMContentLoaded', () => {
  switchTab('home');
});





/* ===============================
   üß© PLAYER CARD OVERLAY SYSTEM
   =============================== */

   function showPlayerCard(fighter) {
  const playerCardHTML = `
    <div class="player-card-overlay" id="player-overlay">
      <div class="player-card">
        ${buildPlayerCardHTML(fighter)}
      </div>
    </div>
  `;
  document.body.insertAdjacentHTML('beforeend', playerCardHTML);
}

function closePlayerCard() {
  const overlay = document.getElementById('player-overlay');
  if (overlay) overlay.remove();
}


  </script>
  
  <style>
  /* crown & floating style refinements */
  .champion-card{background:rgba(0,0,0,0.25);border:1px solid rgba(255,215,0,0.1);border-radius:16px;padding:18px;text-align:center;position:relative;box-shadow:0 4px 20px rgba(0,0,0,0.4);}
  .floating-card{animation:floatCard 6s ease-in-out infinite;}
  @keyframes floatCard{0%,100%{transform:translateY(0)}50%{transform:translateY(-6px)}}
  .champion-crown{color:gold;font-size:34px;text-shadow:0 0 12px gold,0 0 20px rgba(255,215,0,0.6);}
  .champion-title{font-size:14px;letter-spacing:1px;color:#ffd700;margin-top:4px;}
  .champion-name{font-size:22px;font-weight:700;margin:6px 0;color:#fff;}
  .champion-name.clickable:hover{color:#ffd700;cursor:pointer;}
  .champion-name.vacant{color:#9ca3af;font-style:italic;}
  .champion-details{font-size:13px;opacity:0.9;}
  .champion-defenses{color:#4ade80;font-weight:600;}
  .champion-last-defense{font-size:13px;color:#9ca3af;margin-top:4px;}
  .badge{color:#facc15;font-size:16px;margin-right:6px;}
  .fight-history-row{margin:4px 0;font-size:14px;}
  .rank-num{width:36px;text-align:center;color:#9ca3af;font-weight:700;}
  /* crown & floating style refinements */
.champion-card {
  background: rgba(0,0,0,0.25);
  ...
}
.rank-num{width:36px;text-align:center;color:#9ca3af;font-weight:700;}

/* üèÜ Fix Champion Card alignment on mobile */
#world-champion-card,
#caf-champion-card {
  display: flex;
  justify-content: center;
  margin: 0 auto 12px auto;  /* centers horizontally */
  width: fit-content;
  max-width: 95%;            /* prevents overflow on small screens */
}


/* ‚úÖ ADD THIS NEW SECTION BELOW */
.player-header-row {
  display: flex;
  justify-content: space-between;
  padding: 8px 12px;
  font-weight: 700;
  color: #ffd700;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  margin-bottom: 4px;
}
.player-header-left, .player-header-right {
  flex: 1;
}
.player-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  border-bottom: 1px solid rgba(255,255,255,0.05);
}
.players-column-left {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 500;
  color: #fff;
}
.players-column-right {
  width: 70px;
  text-align: right;
  color: #9ca3af;
  font-weight: 600;
}

/* keep whatever comes next */
</style>
<!-- END Part 5 of 6 -->

  </style>
  <!-- END Part 5 of 6 -->
<!-- START Part 6 of 6 -->
<script>
  /* =========================================
     üõ†Ô∏è  ADMIN: add/edit/delete fights & fighters,
           champion assignment, save, and init
     ========================================= */
  
  /* Populate fighter selects used when adding or editing fights */
  function populateEditFightSelects() {
    const fList = fighters.slice().sort((a,b)=> (a.name||'').localeCompare(b.name||''));
    const addF1 = $('add-fight-f1'), addF2 = $('add-fight-f2'), addWinner = $('add-fight-winner');
    const editF1 = $('edit-fight-f1'), editF2 = $('edit-fight-f2'), editWinner = $('edit-fight-winner');
  
    if(addF1) { addF1.innerHTML = '<option value="">-- select fighter --</option>'; }
    if(addF2) { addF2.innerHTML = '<option value="">-- select fighter --</option>'; }
    if(addWinner) { addWinner.innerHTML = '<option value="0">Draw</option>'; }
  
    if(editF1) { editF1.innerHTML = '<option value="">-- select fighter --</option>'; }
    if(editF2) { editF2.innerHTML = '<option value="">-- select fighter --</option>'; }
    if(editWinner) { editWinner.innerHTML = '<option value="0">Draw</option>'; }
  
    fList.forEach(f=>{
      const optHtml = `<option value="${f.id}">${escapeHtml(f.name)} (${escapeHtml(f.region||'‚Äî')})</option>`;

      if(addF1) addF1.insertAdjacentHTML('beforeend', optHtml);
      if(addF2) addF2.insertAdjacentHTML('beforeend', optHtml);
      if(editF1) editF1.insertAdjacentHTML('beforeend', optHtml);
      if(editF2) editF2.insertAdjacentHTML('beforeend', optHtml);
  
      if(addWinner) addWinner.insertAdjacentHTML('beforeend', `<option value="${f.id}">${escapeHtml(f.name)}</option>`);
      if(editWinner) editWinner.insertAdjacentHTML('beforeend', `<option value="${f.id}">${escapeHtml(f.name)}</option>`);
    });
  }
  
  /* Populate admin fights dropdown (input order = firestore order assumed) */
 /* Populate admin fights dropdown (Season 3 only ‚Äî ignore legacy) */
function populateAdminFightsDropdown() {
  const sel = $('admin-fights-dropdown');
  if (!sel) return;

  // ‚úÖ Use the same source logic as populateAdminFightsList()
  const adminFightSource = (allFights || []).filter(f =>
    f.legacy !== true && (f.season === 3 || typeof f.season === 'undefined' || f.season === null)
  );

  sel.innerHTML = '';

  // optional placeholder
  if (adminFightSource.length === 0) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.text = 'No Season 3 fights found';
    sel.appendChild(opt);
    return;
  }

  adminFightSource.slice().reverse().forEach(f => {
    const n1 = fighters.find(x => x.id === f.fighter1)?.name || f.fighter1Name || 'Unknown';
    const n2 = fighters.find(x => x.id === f.fighter2)?.name || f.fighter2Name || 'Unknown';

    const opt = document.createElement('option');
    opt.value = f.id;
    opt.text = `${formatDateShort(f.date)} ‚Äî ${n1} vs ${n2}`;
    sel.appendChild(opt);
  });
}

  
  /* Populate admin fights visual list */
  function populateAdminFightsList(){
  const container = $('admin-fights-list');
  if(!container) return;
  container.innerHTML = '';

  // ‚úÖ Admin fights source: Season 3 only (ignore legacy)
  const adminFightSource = (allFights || []).filter(f =>
    f.legacy !== true && (f.season === 3 || typeof f.season === 'undefined' || f.season === null)
  );

  adminFightSource.slice().reverse().forEach(f=>{
    const n1 = fighters.find(x=>x.id===f.fighter1)?.name || f.fighter1Name || 'Unknown';
    const n2 = fighters.find(x=>x.id===f.fighter2)?.name || f.fighter2Name || 'Unknown';
    const d = document.createElement('div');
    d.style.padding = '8px';
    d.style.borderBottom = '1px solid rgba(255,255,255,0.03)';
    d.innerHTML = `<strong>${formatDateShort(f.date)}</strong> ‚Äî ${escapeHtml(n1)} vs ${escapeHtml(n2)} <span class="small-muted">[${escapeHtml(f.platform||'')}]</span>`;
    container.appendChild(d);
  });
}

  
  /* Populate champion title selects in admin UI */
  function populateChampionTitleSelects(){
    const container = $('champion-titles-container');
    if(!container) return;
    container.innerHTML = '';
    const opts = fighters.slice().map(f=>({ id:f.id, label:`${f.name} (${f.platform||'‚Äî'})` })).sort((a,b)=>a.label.localeCompare(b.label));
  
    // We'll create two-column grid of selects for TITLES array
    TITLES.forEach(title=>{
      const field = mapTitleToField(title);
      const wrapper = document.createElement('div');
      wrapper.style.padding = '8px';
      wrapper.style.borderRadius = '8px';
      wrapper.style.background = 'transparent';
      const label = document.createElement('div');
      label.style.fontWeight = '700';
      label.style.marginBottom = '6px';
      label.textContent = title;
      const sel = document.createElement('select');
      sel.id = `champ-select-${field}`;
      sel.style.width = '100%';
      sel.style.padding = '8px';
      const empty = document.createElement('option'); empty.value = ''; empty.text = '-- Unassigned --';
      sel.appendChild(empty);
      opts.forEach(o=>{
        const opt = document.createElement('option'); opt.value = o.id; opt.text = o.label;
        sel.appendChild(opt);
      });
      // set current value if exists
      if(champions && champions[field]) sel.value = champions[field];
  
      wrapper.appendChild(label);
      wrapper.appendChild(sel);
  
      // For UFL world & CAF add defenses input and last defense display
    // For World, CAF, RBC, ABC add defenses input and last defense display
if (['uflWorld', 'uflIntercontinental', 'rbc', 'abc'].includes(field)) {
  const defLabel = document.createElement('div');
  defLabel.style.marginTop = '8px';
  defLabel.style.fontSize = '13px';
  defLabel.textContent = 'Title Defenses (editable)';

  const defInput = document.createElement('input');
  defInput.type = 'number';
  defInput.min = '0';
  defInput.id = `champ-${field}-def`;
  defInput.style.width = '120px';
  defInput.style.marginTop = '6px';

  // read defenses from champions object using consistent naming
  defInput.value = (typeof champions === 'object' && champions) ? (champions[`${field}Defenses`] || 0) : 0;

  const lastDiv = document.createElement('div');
  lastDiv.style.fontSize = '12px';
  lastDiv.style.marginTop = '6px';

  const lastDate = (typeof champions === 'object' && champions) ? champions[`${field}LastDefense`] : null;
  lastDiv.innerHTML = `Last Defense: ${formatDateShort(lastDate) || 'N/A'}`;

  wrapper.appendChild(defLabel);
  wrapper.appendChild(defInput);
  wrapper.appendChild(lastDiv);
}

  
      // Vacate button for convenience
      const vac = document.createElement('button');
      vac.className = 'btn';
      vac.style.marginTop = '8px';
      vac.textContent = 'Vacate';
      vac.onclick = ()=>{
        if(!confirm(`Vacate ${title}?`)) return;
        const updates = {};
        updates[field] = null;
        if(field === 'uflWorld'){ updates.uflWorldDefenses = 0; updates.uflWorldLastDefense = ''; }
        if(field === 'uflCAF'){ updates.uflCAFDefenses = 0; updates.uflCAFLastDefense = ''; }
        db.collection('settings').doc('champions').set(updates,{ merge:true }).then(()=> { alert('Vacated'); }).catch(e=>{ console.error(e); alert('Failed to vacate'); });
      };
      wrapper.appendChild(vac);
  
      container.appendChild(wrapper);
    });
  
    // If admin is logged in, inject YouTube admin controls near titles container
    injectAdminSocialControls();
  }
  
  /* Save champion assignments from admin form */
  async function saveChampionAssignments(){
    const payload = {};
    TITLES.forEach(title=>{
  const field = mapTitleToField(title);
  const sel = $(`champ-select-${field}`);
  payload[field] = (sel && sel.value) ? sel.value : null;

  if (field === 'uflWorld') {
    const def = parseInt($('champ-uflWorld-def')?.value || 0, 10) || 0;
    payload.uflWorldDefenses = def;
  }
  if (field === 'uflCAF') {
    const def = parseInt($('champ-uflCAF-def')?.value || 0, 10) || 0;
    payload.uflCAFDefenses = def;
  }
  if (field === 'rbc') {
    const def = parseInt($('champ-rbc-def')?.value || 0, 10) || 0;
    payload.rbcDefenses = def;
  }
  if (field === 'abc') {
    const def = parseInt($('champ-abc-def')?.value || 0, 10) || 0;
    payload.abcDefenses = def;
  }
  if (field === 'uflIntercontinental') {
    const def = parseInt($('champ-uflIntercontinental-def')?.value || 0, 10) || 0;
    payload.uflIntercontinentalDefenses = def;
  }
});




    try{
      await db.collection('settings').doc('champions').set(payload, { merge:true });
      alert('Saved champion assignments.');
    }catch(e){ console.error(e); alert('Failed to save champions'); }
  }
  
  /* Clear all champion assignments */
  async function resetChampionAssignments() {
  if (!confirm('Clear all champion assignments?')) return;

  try {
    // üß† Reset all champion fields to defaults
    const payload = {
      uflWorld: null, uflWorldDefenses: 0, uflWorldLastDefense: '',
      uflCAF: null,  uflCAFDefenses: 0,  uflCAFLastDefense: '',
      uflPC: null, uflPS5: null, uflXbox: null,
      rbc: null, rbcDefenses: 0, rbcLastDefense: '',
      abc: null, abcDefenses: 0, abcLastDefense: '',
      rbcPC: null, rbcPS5: null, rbcXbox: null
    };

    // üíæ Save the cleared champion info back to Firestore
    await db.collection('settings').doc('champions').set(payload, { merge: true });

    alert('All champion data has been reset.');
    renderAll(); // üîÅ refresh UI so the changes appear instantly
  } catch (e) {
    console.error('resetChampionAssignments error:', e);
    alert('Failed to reset champion data.');
  }
}

function parseLegacyRows(text) {
  const lines = (text || '').split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  if (lines.length === 0) return {};

  const out = {};
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // skip header row if it contains WIN/LOSS/DRAW
    if (i === 0 && /win/i.test(line) && /loss/i.test(line) && /draw/i.test(line)) continue;

    // Accept tab, pipe, or comma separated
    const parts = line.includes('\t') ? line.split('\t')
                : line.includes('|') ? line.split('|')
                : line.split(',');

    const name = (parts[0] || '').trim();
    const w = parseInt((parts[1] || '0').trim(), 10) || 0;
    const l = parseInt((parts[2] || '0').trim(), 10) || 0;
    const d = parseInt((parts[3] || '0').trim(), 10) || 0;
    const season = parseInt((parts[4] || '1').trim(), 10) || 1;

    if (!name) continue;
    if (season !== 1) continue; // only Season 1 in this tool

    const key = name.toLowerCase();
    out[key] = { w, l, d, season: 1, name };
  }
  return out;
}

async function importSeason1Records() {
  const raw = $('legacy-s1-input')?.value || '';
  const parsed = parseLegacyRows(raw);

  try {
    await db.collection('settings').doc('legacyS1').set({ records: parsed }, { merge: true });
    alert(`Imported Season 1 records: ${Object.keys(parsed).length}`);
  } catch (e) {
    console.error('importSeason1Records error', e);
    alert('Failed to import Season 1 records.');
  }
}

async function loadSeason1RecordsToBox() {
  try {
    const doc = await db.collection('settings').doc('legacyS1').get();
    const records = doc.exists ? (doc.data().records || {}) : {};
    const rows = Object.values(records)
      .sort((a,b)=> (a.name||'').localeCompare(b.name||''))
      .map(r => `${r.name}\t${r.w}\t${r.l}\t${r.d}\t1`)
      .join('\n');

    const header = `PLAYER NAME\tWIN\tLOSS\tDRAW\tSEASON\n`;
    if ($('legacy-s1-input')) $('legacy-s1-input').value = header + rows;
  } catch (e) {
    console.error('loadSeason1RecordsToBox error', e);
    alert('Failed to load Season 1 records.');
  }
}

async function clearSeason1Records() {
  if (!confirm('Clear ALL Season 1 records?')) return;
  try {
    await db.collection('settings').doc('legacyS1').set({ records: {} }, { merge: true });
    alert('Season 1 records cleared.');
  } catch (e) {
    console.error('clearSeason1Records error', e);
    alert('Failed to clear Season 1 records.');
  }
}
  


/* Admin: Add Fighter */
function adminAddFighter(){
  const name = ($('add-fighter-name')?.value || '').trim();
  const region = ($('add-fighter-region')?.value || 'NA').trim();
  if(!name) return alert('Enter a name');
  const payload = { name, region, wins:0, losses:0, draws:0, koWins:0, retired:false, isCAF:false };
  db.collection('fighters').add(payload).then(()=> {
    $('add-fighter-name').value = '';
    // reload UI lists
    if (typeof populateEditFightSelects === 'function') populateEditFightSelects();
    if (typeof populateAdminFighters === 'function') populateAdminFighters();
    alert('Fighter added.');
  }).catch(e=>{ console.error(e); alert('Failed to add fighter'); });
}


function populateMatchmakingSelect() {
  const sel = $("matchmaking-select");
  if (!sel || !fighters.length) return;

  sel.innerHTML = fighters
    .sort((a,b)=> a.name.localeCompare(b.name))
    .map(f => `<option value="${f.id}">${escapeHtml(f.name)} (${f.region})</option>`)
    .join("");
}
  
  /* Recompute ALL fighter stats from fights (safe canonical source of truth) */
  async function recomputeAllFighterStats() {
  const stats = {};
  fighters.forEach(f => {
    stats[f.id] = { 
      wins: 0, losses: 0, draws: 0, koWins: 0,
      cafWins: 0, cafLosses: 0, cafDraws: 0, cafKoWins: 0 // ‚úÖ add CAF record fields
    };
  });

  fights.forEach(ft => {
    const f1 = ft.fighter1, f2 = ft.fighter2;
    if (!f1 || !f2) return;

    const winner = (ft.winner === '0' || ft.winner === 0 || ft.winner === 'draw') ? 'DRAW' : ft.winner;
    const isCAF = !!ft.caf; // ‚úÖ identify CAF fight

    if (winner === 'DRAW') {
      if (stats[f1]) isCAF ? stats[f1].cafDraws++ : stats[f1].draws++;
      if (stats[f2]) isCAF ? stats[f2].cafDraws++ : stats[f2].draws++;
    } else {
      if (stats[winner]) {
        if (isCAF) stats[winner].cafWins++;
        else stats[winner].wins++;
      }
      const loser = (winner === f1) ? f2 : f1;
      if (stats[loser]) {
        if (isCAF) stats[loser].cafLosses++;
        else stats[loser].losses++;
      }

      if ((ft.method || '').toLowerCase().includes('KO/TKO')) {
        if (stats[winner]) {
          if (isCAF) stats[winner].cafKoWins++;
          else stats[winner].koWins++;
        }
      }
    }
  });

  // ‚úÖ batch update Firestore with both normal and CAF stats
  const batch = db.batch();
  Object.keys(stats).forEach(fid => {
    const ref = db.collection('fighters').doc(fid);
    batch.set(ref, stats[fid], { merge: true });
  });

  try {
    await batch.commit();
    console.log('‚úÖ Recomputed fighter stats (including CAF).');
  } catch (e) {
    console.error('üî• recomputeAllFighterStats error', e);
  }
}

  
  /* Admin: Add Fight */
  async function adminAddFight(){
  const f1 = $('add-fight-f1')?.value;
  const f2 = $('add-fight-f2')?.value;
  const method = $('add-fight-method')?.value || '';
  const winner = $('add-fight-winner')?.value || '0';
  const date = $('add-fight-date')?.value;
  const caf = $('add-fight-caf')?.checked || false; // ‚úÖ checkbox uses .checked
  const titleFight = ($('add-fight-titlefight')?.value === 'yes'); // ‚úÖ matches your <option value="yes">
  const bonus = $('add-fight-bonus')?.value || 'none';
  const region = $('add-fight-region')?.value || 'NA'; // ‚úÖ optional, if region exists
  const ic = ($('add-fight-ic')?.value === 'yes');


  if (!f1 || !f2) return alert('Select both fighters');
  if (f1 === f2) return alert('Fighter cannot fight themselves');
  if (!date) return alert('Select a date');

  const payload = {
    fighter1: f1,
    fighter2: f2,
    fighter1Name: fighters.find(x => x.id === f1)?.name || '',
    fighter2Name: fighters.find(x => x.id === f2)?.name || '',
    method,
    winner: winner || '0',
    date,
    caf,
    ic,
    region,
    titleFight, // ‚úÖ saves true/false to Firestore
    bonus       // ‚úÖ saves POTN, FOTN, or none
  };

  try {
    await db.collection('fights').add(payload);
    console.log('‚úÖ Fight added to Firestore:', payload);
    await recomputeAllFighterStats();
    populateAdminFightsDropdown();
    populateAdminFightsList();
    renderAll();
    alert('Fight added successfully.');
  } catch (e) {
    console.error('üî• Failed to add fight:', e);
    alert('Failed to add fight');
  }
}


  
  /* Admin: Edit selected fight - open modal and populate */
  function adminEditSelectedFight(){
    const sel = $('admin-fights-dropdown');
    if(!sel || !sel.value) return alert('Select a fight');
    const fid = sel.value;
    const fight = fights.find(f=>f.id===fid);
    if(!fight) return alert('Fight not found');
    $('edit-fight-f1').value = fight.fighter1 || '';
    $('edit-fight-f2').value = fight.fighter2 || '';
    $('edit-fight-region').value = fight.region || 'NA';

    $('edit-fight-method').value = fight.method || '';
    $('edit-fight-winner').value = fight.winner || '0';
    $('edit-fight-date').value = fight.date ? fight.date.split('T')[0] : fight.date;
    $('edit-fight-caf').value = fight.caf ? 'true' : 'false';
    $('edit-fight-modal').dataset.editing = fid;
    $('edit-fight-modal').classList.remove('hidden');
  }
  
  /* Close edit fight modal */
  function closeEditFightModal(){
    const modal = $('edit-fight-modal');
    if(!modal) return;
    modal.classList.add('hidden');
    delete modal.dataset.editing;
  }
  
  /* Save edited fight */
  async function saveEditedFight(){
    const fid = $('edit-fight-modal')?.dataset?.editing;
    if(!fid) return alert('No fight selected');
    const f1 = $('edit-fight-f1').value;
    const f2 = $('edit-fight-f2').value;
    const region = $('edit-fight-region')?.value || 'NA';

    const method = $('edit-fight-method').value;
    const winner = $('edit-fight-winner').value || '0';
    const date = $('edit-fight-date').value;
    const caf = ($('edit-fight-caf').value === 'true');
  
    if(!f1 || !f2) return alert('Select both fighters');
    if(f1 === f2) return alert('Fighters must be different');
    if(!date) return alert('Select date');
  
    try{
      await db.collection('fights').doc(fid).set({
  fighter1: f1,
  fighter2: f2,
  fighter1Name: fighters.find(x => x.id === f1)?.name || '',
  fighter2Name: fighters.find(x => x.id === f2)?.name || '',
  method,
  winner: winner || '0',
  date,
  caf,
  region
}, { merge: true });

      await recomputeAllFighterStats();
      closeEditFightModal();
      populateAdminFightsDropdown();
      populateAdminFightsList();
      renderAll();
      alert('Saved.');
    }catch(e){ console.error(e); alert('Failed to save fight'); }
  }
  
  /* Confirm delete fight within edit modal */
  function confirmDeleteFight(){
    if(!confirm('Delete this fight?')) return;
    const fid = $('edit-fight-modal')?.dataset?.editing;
    if(!fid) return alert('No fight selected');
    adminDeleteFight(fid);
  }
  
/* üóëÔ∏è Admin: Delete selected fight */
async function adminDeleteSelectedFight() {
  const selectedFightId = $('admin-fights-dropdown').value;
  if (!selectedFightId) {
    alert('Select a fight first!');
    return;
  }

  const confirmDelete = confirm('Are you sure you want to delete this fight?');
  if (!confirmDelete) return;

  try {
    // üóëÔ∏è Delete from Firestore
    await db.collection("fights").doc(selectedFightId).delete();


// üîÅ Recompute updated stats
await recomputeAllFighterStats();

    // üßÆ Recompute and render rankings
    const { world, caf } = computeRankings();
    renderRankings(world, 'world-rankings');
    renderRankings(caf, 'caf-rankings');

    // ‚ôªÔ∏è Refresh Admin UI
    populateAdminFightsDropdown();
    populateAdminFightsList();
    renderAll();

    alert('Fight deleted and stats updated.');
  } catch (e) {
    console.error(e);
    alert('Failed to delete fight.');
  }
}


async function importSeason2Legacy() {
  if (!confirm('Import Season 2 legacy data? This should only be done ONCE.')) return;

  const fightersData = JSON.parse(
    document.getElementById('legacyFightersInput').value
  );

  const fightsData = JSON.parse(
    document.getElementById('legacyFightsInput').value
  );

  const fighterIdMap = {};

  // 1Ô∏è‚É£ Merge fighters
  for (const f of fightersData) {
    const name = f.name?.trim();
    if (!name) continue;

    const existing = fighters.find(x =>
      x.name?.toLowerCase() === name.toLowerCase()
    );

    if (existing) {
      fighterIdMap[f.id] = existing.id;
    } else {
      const ref = await db.collection('fighters').add({
        name,
        legacyOnly: true,
        createdFromSeason: 2
      });
      fighterIdMap[f.id] = ref.id;
    }
  }

  // 2Ô∏è‚É£ Import fights
  let imported = 0;

  for (const fight of fightsData) {
    const fighter1 = fighterIdMap[fight.fighter1];
    const fighter2 = fighterIdMap[fight.fighter2];
    const winner = fighterIdMap[fight.winner] || null;

    if (!fighter1 || !fighter2) continue;

    await db.collection('fights').add({
      ...fight,
      fighter1,
      fighter2,
      winner,
      season: 2,
      legacy: true
    });

    imported++;
  }

  alert(`Season 2 import complete. Fights imported: ${imported}`);
}

async function saveLegacyReign(){
  const fighterName = ($('reign-fighter')?.value || '').trim();
  const title = ($('reign-title')?.value || '').trim();
  const season = parseInt($('reign-season')?.value || '0', 10) || 0;
  const wonDate = $('reign-won')?.value || '';
  const lostDate = $('reign-lost')?.value || '';

  if(!fighterName || !title || !season){
    alert('Fighter Name, Title, and Season are required.');
    return;
  }

  const fighterKey = fighterName.toLowerCase();

  const rawLines = ($('reign-defenses')?.value || '').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  const defenses = rawLines.map(line=>{
    const parts = line.includes('|') ? line.split('|').map(p=>p.trim()) : line.split('\t').map(p=>p.trim());
    return {
      date: parts[0] || '',
      opponent: parts[1] || '',
      event: parts[2] || '',
      method: parts[3] || ''
    };
  });

  try{
    await db.collection('legacy_title_reigns').add({
      fighterName,
      fighterKey,
      title,
      season,
      wonDate,
      lostDate,
      defenses
    });
    alert('Legacy reign saved.');
  }catch(e){
    console.error('saveLegacyReign error', e);
    alert('Failed to save reign.');
  }
}

  
  /* Admin: delete fighter */
  function deleteFighter(id){
    if(!confirm('Delete fighter? This removes them from fighters collection (fights remain).')) return;
    db.collection('fighters').doc(id).delete().then(()=>{ alert('Deleted fighter.'); }).catch(e=>{ console.error(e); alert('Failed'); });
  }
  
  /* Toggle retire/unretire */
  function toggleRetire(id){
    const f = fighters.find(x=>x.id===id);
    if(!f) return;
    const newVal = !f.retired;
    if(!confirm(`${newVal ? 'Retire' : 'Unretire'} ${f.name}?`)) return;
    db.collection('fighters').doc(id).set({ retired:newVal }, { merge:true }).then(()=>{ alert('Updated.'); }).catch(e=>{ console.error(e); alert('Failed'); });
  }
  
  /* Edit fighter inline (simple prompt UI) */
  function openEditFighter(id){
    const f = fighters.find(x=>x.id===id);
    if(!f) return;
    const newName = prompt('Edit fighter name:', f.name);
    if(newName === null) return;
    const newPlatform = prompt('Edit platform (PC / PS5 / XBOX):', f.platform || 'PC');
    if(newPlatform === null) return;
    db.collection('fighters').doc(id).set({ name:newName.trim(), platform:newPlatform.trim() }, { merge:true }).then(()=>{ alert('Saved'); }).catch(e=>{ console.error(e); alert('Failed'); });
  }
  
  /* Map title string to settings field */
function mapTitleToField(title) {
  switch (title) {
    case 'UFL World Champion': return 'uflWorld';
    case 'RBC Champion': return 'rbc';
    case 'ABC Champion': return 'abc';
    case 'UFL CAF Champion': return 'uflCAF';
    case 'UFL Intercontinental Champion': return 'uflIntercontinental';

    default:
      return title.replace(/\s+/g, '').toLowerCase();
  }
}


function populateLegacyReignDropdown(){
  const sel = $('reign-select');
  if(!sel) return;

  const current = sel.value;
  sel.innerHTML = `<option value="">-- New Reign --</option>`;

  (legacyTitleReigns || [])
    .slice()
    .sort((a,b)=>{
      const an = (a.fighterName||'').localeCompare(b.fighterName||'');
      if(an !== 0) return an;
      const as = (a.season||0) - (b.season||0);
      if(as !== 0) return as;
      return (a.title||'').localeCompare(b.title||'');
    })
    .forEach(r=>{
      const opt = document.createElement('option');
      opt.value = r.id;
      opt.textContent = `${r.fighterName} ‚Äî ${r.title} (S${r.season})`;
      sel.appendChild(opt);
    });

  sel.value = current || '';
}
 
function clearLegacyReignForm(){
  const sel = $('reign-select');
  if (sel) sel.value = '';

  $('reign-fighter').value = '';
  $('reign-title').value = '';
  $('reign-season').value = 2;
  $('reign-won').value = '';
  $('reign-lost').value = '';
  $('reign-defenses').value = '';
}

function loadSelectedLegacyReign(){
  const sel = $('reign-select');
  const id = sel?.value || '';
  if(!id) { clearLegacyReignForm(); return; }

  const reign = (legacyTitleReigns || []).find(r => r.id === id);
  if(!reign) { clearLegacyReignForm(); return; }

  $('reign-fighter').value = reign.fighterName || '';
  $('reign-title').value = reign.title || '';
  $('reign-season').value = reign.season || 2;
  $('reign-won').value = reign.wonDate || '';
  $('reign-lost').value = reign.lostDate || '';

  const defenses = Array.isArray(reign.defenses) ? reign.defenses : [];
  $('reign-defenses').value = defenses
    .map(d => `${d.date || ''} | ${d.opponent || ''} | ${d.event || ''} | ${d.method || ''}`.trim())
    .join('\n');
}

async function deleteSelectedLegacyReign(){
  const sel = $('reign-select');
  const id = sel?.value || '';
  if(!id) return alert('Select a reign to delete.');

  const reign = (legacyTitleReigns || []).find(r => r.id === id);
  const label = reign
    ? `${reign.fighterName || 'Unknown'} ‚Äî ${reign.title || 'Title'} (S${reign.season || '?'})`
    : id;

  if(!confirm(`Delete this reign?\n\n${label}`)) return;

  try{
    await db.collection('legacy_title_reigns').doc(id).delete();
    clearLegacyReignForm();
    alert('Reign deleted.');
    // snapshot listener should refresh dropdown automatically
  }catch(e){
    console.error('deleteSelectedLegacyReign error', e);
    alert('Failed to delete reign (check Firestore rules + console).');
  }
}

function getLegacyManualNames(){
  const recs = legacyManualRecords || {};
  return Object.keys(recs).map(k => (recs[k]?.name || k)).filter(Boolean);
}

  /* Inject admin social controls (YouTube save UI) */
  function injectAdminSocialControls(){
    if(!sessionStorage.getItem('isAdmin')) return;
    if($('admin-youtube-control')) return; // already injected
    const container = $('champion-titles-container');
    if(!container) return;
    const div = document.createElement('div');
    div.id = 'admin-youtube-control';
    div.style.gridColumn = 'span 2';
    div.className = 'frosted';
    div.innerHTML = `<div style="font-weight:700;margin-bottom:6px;">Social / YouTube</div>
      <div class="small-muted">Enter a playlist ID to enable embedding on Social tab</div>
      <div style="margin-top:8px;"><input id="admin-youtube-playlist" placeholder="YouTube playlist ID" style="width:60%;padding:8px;" /><button class="btn btn-primary" style="margin-left:8px;" onclick="saveYoutubePlaylist()">Save</button></div>`;
    container.parentElement.appendChild(div);
    setTimeout(()=>{ $('admin-youtube-playlist').value = champions.youtubePlaylist || ''; }, 120);
  }
  
  /* Save YouTube playlist ID into champions settings doc */
  function saveYoutubePlaylist(){
    const val = $('admin-youtube-playlist')?.value.trim() || '';
    db.collection('settings').doc('champions').set({ youtubePlaylist: val }, { merge:true }).then(()=>{ alert('Saved'); }).catch(e=>{ console.error(e); alert('Failed'); });
  }
  
  /* Populate admin fighters table */
  function populateAdminFighters(){
    const tbody = $('admin-fighters-list');
    if(!tbody) return;
    tbody.innerHTML = '';
    fighters.slice().forEach(f=>{
      const combined = buildCombinedMap().find(c=> c.ids.includes(f.id));
      const points = combined ? (combined.points || 0) : 0;
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${escapeHtml(f.name)} ${f.retired ? '<span style="color:#f87171;font-size:12px;margin-left:6px;">[Retired]</span>' : ''}</td>
        <td>${escapeHtml(f.region||'‚Äî')}</td>
        <td>${(f.wins||0)}-${(f.losses||0)}-${(f.draws||0)}</td>

        
        <td>
          <button class="btn" onclick="openEditFighter('${f.id}')"><i class="fas fa-edit"></i></button>
          <button class="btn" onclick="toggleRetire('${f.id}')">${f.retired ? '<i class="fas fa-undo"></i>' : '<i class="fas fa-user-slash"></i>'}</button>
          <button class="btn btn-danger" onclick="deleteFighter('${f.id}')"><i class="fas fa-trash"></i></button>
        </td>
      `;
      tbody.appendChild(tr);
    });
  }



  
  /* ADMIN: Login / Logout (simple check against stored ADMIN_PW or fallback test password) */
  function attemptAdminLogin(){
    const input = $('admin-pass')?.value || '';
    $('admin-login-error').style.display = 'none';
    const ok = (window.ADMIN_PW && input === window.ADMIN_PW) || (!window.ADMIN_PW && input === 'ufltest123');
    if(ok){
      sessionStorage.setItem('isAdmin','true');
      $('admin-login').classList.add('hidden');
      $('admin-dashboard').classList.remove('hidden');
      populateChampionTitleSelects();
      populateAdminFighters();
      populateAdminFightsDropdown();
      populateAdminFightsList();
      injectAdminSocialControls();
      alert('Admin unlocked.');
    } else {
      $('admin-login-error').textContent = 'Invalid password';
      $('admin-login-error').style.display = 'block';
    }
  }
  function logoutAdmin(){
    sessionStorage.removeItem('isAdmin');
    $('admin-dashboard').classList.add('hidden');
    $('admin-login').classList.remove('hidden');
    switchTab('world');
  }
  
  /* Utility to repopulate admin UI parts */
  function repopulateAllAdminViews(){
    populateEditFightSelects();
    populateAdminFightsDropdown();
    populateAdminFightsList();
    populateChampionTitleSelects();
    populateAdminFighters();
  }
  
  /* Initialize page (called at load) */
  function initPage(){
    populateEditFightSelects();
    populateAdminFightsDropdown();
    populateAdminFightsList();
    populateChampionTitleSelects();
    populateAdminFighters();
    renderAll();
    if(sessionStorage.getItem('isAdmin')){
      $('admin-login')?.classList.add('hidden');
      $('admin-dashboard')?.classList.remove('hidden');
      injectAdminSocialControls();
    }
  }
  
  /* Close modals when clicking backdrop */
  document.addEventListener('click', (e)=>{
    if(e.target.classList && e.target.classList.contains('modal-backdrop')){
      if(e.target.id === 'fighter-modal') closeFighterModal();
      if(e.target.id === 'edit-fight-modal') closeEditFightModal();
    }
  });
  
  /* Kick off initial setup after listeners have time to fill data */
  setTimeout(initPage, 600);
  </script>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  
<div id="compare-modal" class="player-card-overlay" style="display:none;">
<div class="modal frosted" style="max-width:900px; position:relative;">

  <button class="btn btn-danger" 
          onclick="closeCompareModal()" 
          style="position:absolute; top:10px; right:14px; font-size:18px;">
    ‚úñ
  </button>

  <h2 id="compare-title" 
      style="text-align:center; color:var(--gold); font-family:Orbitron; margin-bottom:12px;">
    Compare Fighters
  </h2>

  <div style="margin-bottom:15px;">
    <label style="font-size:14px; opacity:0.9;">Select Opponent</label>
    <select id="compare-dropdown" 
            onchange="runComparison()" 
            style="width:100%; padding:8px; border-radius:6px; margin-top:6px;">
    </select>
  </div>

  <div id="comparison-output" style="padding-bottom:20px;"></div>

</div>
</div>


  </body>
  </html>
  <!-- END Part 6 of 6 -->
        
